/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.3.0.0 (NJsonSchema v10.1.11.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import axios, { AxiosInstance, AxiosRequestConfig, AxiosResponse } from 'axios';

export interface IRequestObjectsClient {
    /**
     * List all RequestObjects
     * @param page (optional) 
     * @param size (optional) 
     * @param title (optional) 
     * @param requestCategoryId (optional) 
     */
    get(page: number | null | undefined, size: number | null | undefined, title: string | null | undefined, requestCategoryId: string | null | undefined): Promise<PagedResultOfRequestObject>;
    /**
     * List all RequestObjects
     */
    getStrippedByCategory(requestCategoryId: string): Promise<IdValueDtoOfGuid[]>;
    /**
     * Get Whether list is valid or not
     */
    getValidity(lastUpdated: Date): Promise<boolean>;
}

export class RequestObjectsClient implements IRequestObjectsClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * List all RequestObjects
     * @param page (optional) 
     * @param size (optional) 
     * @param title (optional) 
     * @param requestCategoryId (optional) 
     */
    get(page: number | null | undefined, size: number | null | undefined, title: string | null | undefined, requestCategoryId: string | null | undefined): Promise<PagedResultOfRequestObject> {
        let url_ = this.baseUrl + "/api/requestobjects?";
        if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&"; 
        if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&"; 
        if (title !== undefined)
            url_ += "Title=" + encodeURIComponent("" + title) + "&"; 
        if (requestCategoryId !== undefined)
            url_ += "RequestCategoryId=" + encodeURIComponent("" + requestCategoryId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<PagedResultOfRequestObject> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultOfRequestObject.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultOfRequestObject>(<any>null);
    }

    /**
     * List all RequestObjects
     */
    getStrippedByCategory(requestCategoryId: string): Promise<IdValueDtoOfGuid[]> {
        let url_ = this.baseUrl + "/api/requestobjects/{requestCategoryId}/stripped";
        if (requestCategoryId === undefined || requestCategoryId === null)
            throw new Error("The parameter 'requestCategoryId' must be defined.");
        url_ = url_.replace("{requestCategoryId}", encodeURIComponent("" + requestCategoryId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGetStrippedByCategory(_response);
        });
    }

    protected processGetStrippedByCategory(response: AxiosResponse): Promise<IdValueDtoOfGuid[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(IdValueDtoOfGuid.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<IdValueDtoOfGuid[]>(<any>null);
    }

    /**
     * Get Whether list is valid or not
     */
    getValidity(lastUpdated: Date): Promise<boolean> {
        let url_ = this.baseUrl + "/api/requestobjects/validity";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(lastUpdated);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "GET",
            url: url_,
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGetValidity(_response);
        });
    }

    protected processGetValidity(response: AxiosResponse): Promise<boolean> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<boolean>(<any>null);
    }
}

export interface IOfficialDocumentsClient {
    /**
     * Get ApplicationDocuments list
     * @param page (optional) 
     * @param size (optional) 
     * @param title (optional) 
     * @param type (optional) 
     * @param minCreationDate (optional) 
     * @param maxCreationDate (optional) 
     */
    get(page: number | null | undefined, size: number | null | undefined, title: string | null | undefined, type: DocumentType | null | undefined, minCreationDate: Date | null | undefined, maxCreationDate: Date | null | undefined): Promise<PagedResultOfApplicationDocument>;
}

export class OfficialDocumentsClient implements IOfficialDocumentsClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * Get ApplicationDocuments list
     * @param page (optional) 
     * @param size (optional) 
     * @param title (optional) 
     * @param type (optional) 
     * @param minCreationDate (optional) 
     * @param maxCreationDate (optional) 
     */
    get(page: number | null | undefined, size: number | null | undefined, title: string | null | undefined, type: DocumentType | null | undefined, minCreationDate: Date | null | undefined, maxCreationDate: Date | null | undefined): Promise<PagedResultOfApplicationDocument> {
        let url_ = this.baseUrl + "/api/officialdocuments?";
        if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&"; 
        if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&"; 
        if (title !== undefined)
            url_ += "Title=" + encodeURIComponent("" + title) + "&"; 
        if (type !== undefined)
            url_ += "Type=" + encodeURIComponent("" + type) + "&"; 
        if (minCreationDate !== undefined)
            url_ += "MinCreationDate=" + encodeURIComponent(minCreationDate ? "" + minCreationDate.toJSON() : "") + "&"; 
        if (maxCreationDate !== undefined)
            url_ += "MaxCreationDate=" + encodeURIComponent(maxCreationDate ? "" + maxCreationDate.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<PagedResultOfApplicationDocument> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultOfApplicationDocument.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultOfApplicationDocument>(<any>null);
    }
}

export interface IRequestCategoriesClient {
    /**
     * List all RequestCategorys
     * @param page (optional) 
     * @param size (optional) 
     * @param title (optional) 
     */
    get(page: number | null | undefined, size: number | null | undefined, title: string | null | undefined): Promise<PagedResultOfRequestCategory>;
    /**
     * List all RequestObjects
     */
    getStripped(): Promise<IdValueDtoOfGuid[]>;
    /**
     * List all RequestObjects
     */
    getStrippedByNature(requestNature: RequestNatureType): Promise<IdValueDtoOfGuid[]>;
}

export class RequestCategoriesClient implements IRequestCategoriesClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * List all RequestCategorys
     * @param page (optional) 
     * @param size (optional) 
     * @param title (optional) 
     */
    get(page: number | null | undefined, size: number | null | undefined, title: string | null | undefined): Promise<PagedResultOfRequestCategory> {
        let url_ = this.baseUrl + "/api/requestcategories?";
        if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&"; 
        if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&"; 
        if (title !== undefined)
            url_ += "Title=" + encodeURIComponent("" + title) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<PagedResultOfRequestCategory> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultOfRequestCategory.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultOfRequestCategory>(<any>null);
    }

    /**
     * List all RequestObjects
     */
    getStripped(): Promise<IdValueDtoOfGuid[]> {
        let url_ = this.baseUrl + "/api/requestcategories/stripped";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGetStripped(_response);
        });
    }

    protected processGetStripped(response: AxiosResponse): Promise<IdValueDtoOfGuid[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(IdValueDtoOfGuid.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<IdValueDtoOfGuid[]>(<any>null);
    }

    /**
     * List all RequestObjects
     */
    getStrippedByNature(requestNature: RequestNatureType): Promise<IdValueDtoOfGuid[]> {
        let url_ = this.baseUrl + "/api/requestcategories/{requestNature}/stripped";
        if (requestNature === undefined || requestNature === null)
            throw new Error("The parameter 'requestNature' must be defined.");
        url_ = url_.replace("{requestNature}", encodeURIComponent("" + requestNature)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGetStrippedByNature(_response);
        });
    }

    protected processGetStrippedByNature(response: AxiosResponse): Promise<IdValueDtoOfGuid[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(IdValueDtoOfGuid.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<IdValueDtoOfGuid[]>(<any>null);
    }
}

export interface IAnnouncementsClient {
    /**
     * Get Announcements list
     * @param page (optional) 
     * @param size (optional) 
     * @param minCreationDate (optional) 
     * @param maxCreationDate (optional) 
     * @param title (optional) 
     * @param isPublished (optional) 
     */
    get(page: number | null | undefined, size: number | null | undefined, minCreationDate: Date | null | undefined, maxCreationDate: Date | null | undefined, title: string | null | undefined, isPublished: boolean | null | undefined): Promise<PagedResultOfAnnouncement>;
    /**
     * Get Announcement by id
     */
    getById(id: string): Promise<Announcement>;
}

export class AnnouncementsClient implements IAnnouncementsClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * Get Announcements list
     * @param page (optional) 
     * @param size (optional) 
     * @param minCreationDate (optional) 
     * @param maxCreationDate (optional) 
     * @param title (optional) 
     * @param isPublished (optional) 
     */
    get(page: number | null | undefined, size: number | null | undefined, minCreationDate: Date | null | undefined, maxCreationDate: Date | null | undefined, title: string | null | undefined, isPublished: boolean | null | undefined): Promise<PagedResultOfAnnouncement> {
        let url_ = this.baseUrl + "/api/announcements?";
        if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&"; 
        if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&"; 
        if (minCreationDate !== undefined)
            url_ += "MinCreationDate=" + encodeURIComponent(minCreationDate ? "" + minCreationDate.toJSON() : "") + "&"; 
        if (maxCreationDate !== undefined)
            url_ += "MaxCreationDate=" + encodeURIComponent(maxCreationDate ? "" + maxCreationDate.toJSON() : "") + "&"; 
        if (title !== undefined)
            url_ += "Title=" + encodeURIComponent("" + title) + "&"; 
        if (isPublished !== undefined)
            url_ += "IsPublished=" + encodeURIComponent("" + isPublished) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<PagedResultOfAnnouncement> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultOfAnnouncement.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultOfAnnouncement>(<any>null);
    }

    /**
     * Get Announcement by id
     */
    getById(id: string): Promise<Announcement> {
        let url_ = this.baseUrl + "/api/announcements/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: AxiosResponse): Promise<Announcement> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Announcement.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Announcement>(<any>null);
    }
}

export interface IAuthClient {
    /**
     * Signing IN
     */
    signIn(userSignInData: UserSignInDto): Promise<AuthenticationResult>;
    /**
     * Logging out
     */
    logOut(deviceToken: string): Promise<void>;
}

export class AuthClient implements IAuthClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * Signing IN
     */
    signIn(userSignInData: UserSignInDto): Promise<AuthenticationResult> {
        let url_ = this.baseUrl + "/api/auth/signin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(userSignInData);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processSignIn(_response);
        });
    }

    protected processSignIn(response: AxiosResponse): Promise<AuthenticationResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AuthenticationResult.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AuthenticationResult>(<any>null);
    }

    /**
     * Logging out
     */
    logOut(deviceToken: string): Promise<void> {
        let url_ = this.baseUrl + "/api/auth/logout";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(deviceToken);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json", 
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processLogOut(_response);
        });
    }

    protected processLogOut(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }
}

export interface ICitiesClient {
    /**
     * List of cities
     */
    get(): Promise<string[]>;
}

export class CitiesClient implements ICitiesClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * List of cities
     */
    get(): Promise<string[]> {
        let url_ = this.baseUrl + "/api/cities";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<string[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string[]>(<any>null);
    }
}

export interface IDocumentsClient {
    /**
     * Download a document
     * @param isThumbnail (optional) 
     */
    download(type: DocumentType, id: string, isThumbnail: boolean | undefined): Promise<FileResponse>;
    /**
     * Download static documents by Value
     */
    downloadRequestNatureImage(type: RequestNatureType): Promise<FileResponse>;
    /**
     * Download static documents by Value
     */
    downloadIncentiveCategoryImage(type: GameType): Promise<FileResponse>;
    /**
     * Get application documents
     */
    getApplicationDocuments(documentType: DocumentType): Promise<DocumentDto[]>;
}

export class DocumentsClient implements IDocumentsClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * Download a document
     * @param isThumbnail (optional) 
     */
    download(type: DocumentType, id: string, isThumbnail: boolean | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/documents/download/{type}/{id}?";
        if (type === undefined || type === null)
            throw new Error("The parameter 'type' must be defined.");
        url_ = url_.replace("{type}", encodeURIComponent("" + type)); 
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        if (isThumbnail === null)
            throw new Error("The parameter 'isThumbnail' cannot be null.");
        else if (isThumbnail !== undefined)
            url_ += "isThumbnail=" + encodeURIComponent("" + isThumbnail) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            responseType: "blob",
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processDownload(_response);
        });
    }

    protected processDownload(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Promise.resolve({ fileName: fileName, status: status, data: response.data as Blob, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    /**
     * Download static documents by Value
     */
    downloadRequestNatureImage(type: RequestNatureType): Promise<FileResponse> {
        let url_ = this.baseUrl + "/documents/download/requestnature/{type}";
        if (type === undefined || type === null)
            throw new Error("The parameter 'type' must be defined.");
        url_ = url_.replace("{type}", encodeURIComponent("" + type)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            responseType: "blob",
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processDownloadRequestNatureImage(_response);
        });
    }

    protected processDownloadRequestNatureImage(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Promise.resolve({ fileName: fileName, status: status, data: response.data as Blob, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    /**
     * Download static documents by Value
     */
    downloadIncentiveCategoryImage(type: GameType): Promise<FileResponse> {
        let url_ = this.baseUrl + "/documents/download/incentivecategory/{type}";
        if (type === undefined || type === null)
            throw new Error("The parameter 'type' must be defined.");
        url_ = url_.replace("{type}", encodeURIComponent("" + type)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            responseType: "blob",
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processDownloadIncentiveCategoryImage(_response);
        });
    }

    protected processDownloadIncentiveCategoryImage(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Promise.resolve({ fileName: fileName, status: status, data: response.data as Blob, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    /**
     * Get application documents
     */
    getApplicationDocuments(documentType: DocumentType): Promise<DocumentDto[]> {
        let url_ = this.baseUrl + "/documents/appdocuments";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(documentType);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "GET",
            url: url_,
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGetApplicationDocuments(_response);
        });
    }

    protected processGetApplicationDocuments(response: AxiosResponse): Promise<DocumentDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DocumentDto.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DocumentDto[]>(<any>null);
    }
}

export interface IExcellenceProgramsClient {
    /**
     * Get Excellence Program
     */
    getRetailerClassification(): Promise<ExcellenceProgramDto>;
    /**
     * Get Incentives
     */
    getIncentives(): Promise<IncentiveDto[]>;
}

export class ExcellenceProgramsClient implements IExcellenceProgramsClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * Get Excellence Program
     */
    getRetailerClassification(): Promise<ExcellenceProgramDto> {
        let url_ = this.baseUrl + "/api/excellenceprograms/classification";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGetRetailerClassification(_response);
        });
    }

    protected processGetRetailerClassification(response: AxiosResponse): Promise<ExcellenceProgramDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = ExcellenceProgramDto.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<ExcellenceProgramDto>(<any>null);
    }

    /**
     * Get Incentives
     */
    getIncentives(): Promise<IncentiveDto[]> {
        let url_ = this.baseUrl + "/api/excellenceprograms/incentives";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGetIncentives(_response);
        });
    }

    protected processGetIncentives(response: AxiosResponse): Promise<IncentiveDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(IncentiveDto.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<IncentiveDto[]>(<any>null);
    }
}

export interface IInvoicesClient {
    /**
     * List Invoices By Date
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param minAmount (optional) 
     * @param maxAmount (optional) 
     * @param retailerId (optional) 
     */
    getByDate(startDate: Date | null | undefined, endDate: Date | null | undefined, minAmount: number | null | undefined, maxAmount: number | null | undefined, retailerId: string | null | undefined): Promise<InvoiceDto[]>;
    /**
     * Get status invoices
     */
    getInvoices(): Promise<StatusInvoiceDto>;
    /**
     * Get Loyalty Points
     */
    getRetailerLoyaltyPoints(): Promise<LoyaltyPointsDto>;
}

export class InvoicesClient implements IInvoicesClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * List Invoices By Date
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param minAmount (optional) 
     * @param maxAmount (optional) 
     * @param retailerId (optional) 
     */
    getByDate(startDate: Date | null | undefined, endDate: Date | null | undefined, minAmount: number | null | undefined, maxAmount: number | null | undefined, retailerId: string | null | undefined): Promise<InvoiceDto[]> {
        let url_ = this.baseUrl + "/api/invoices?";
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (minAmount !== undefined)
            url_ += "MinAmount=" + encodeURIComponent("" + minAmount) + "&"; 
        if (maxAmount !== undefined)
            url_ += "MaxAmount=" + encodeURIComponent("" + maxAmount) + "&"; 
        if (retailerId !== undefined)
            url_ += "RetailerId=" + encodeURIComponent("" + retailerId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGetByDate(_response);
        });
    }

    protected processGetByDate(response: AxiosResponse): Promise<InvoiceDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(InvoiceDto.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<InvoiceDto[]>(<any>null);
    }

    /**
     * Get status invoices
     */
    getInvoices(): Promise<StatusInvoiceDto> {
        let url_ = this.baseUrl + "/api/invoices/summary";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGetInvoices(_response);
        });
    }

    protected processGetInvoices(response: AxiosResponse): Promise<StatusInvoiceDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = StatusInvoiceDto.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<StatusInvoiceDto>(<any>null);
    }

    /**
     * Get Loyalty Points
     */
    getRetailerLoyaltyPoints(): Promise<LoyaltyPointsDto> {
        let url_ = this.baseUrl + "/api/invoices/loyaltypoints";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGetRetailerLoyaltyPoints(_response);
        });
    }

    protected processGetRetailerLoyaltyPoints(response: AxiosResponse): Promise<LoyaltyPointsDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = LoyaltyPointsDto.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<LoyaltyPointsDto>(<any>null);
    }
}

export interface INotificationsClient {
    /**
     * List all Notifications
     * @param page (optional) 
     * @param size (optional) 
     * @param type (optional) 
     * @param title (optional) 
     * @param body (optional) 
     * @param targetRetailerId (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     */
    get(page: number | null | undefined, size: number | null | undefined, type: NotificationType | null | undefined, title: string | null | undefined, body: string | null | undefined, targetRetailerId: string | null | undefined, startDate: Date | null | undefined, endDate: Date | null | undefined): Promise<PagedResultOfNotification>;
    /**
     * All Alerts
     */
    getStrippedNotifications(): Promise<IdValueDtoOfGuid[]>;
    /**
     * Delete a Notification
     */
    delete(id: string): Promise<Unit>;
}

export class NotificationsClient implements INotificationsClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * List all Notifications
     * @param page (optional) 
     * @param size (optional) 
     * @param type (optional) 
     * @param title (optional) 
     * @param body (optional) 
     * @param targetRetailerId (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     */
    get(page: number | null | undefined, size: number | null | undefined, type: NotificationType | null | undefined, title: string | null | undefined, body: string | null | undefined, targetRetailerId: string | null | undefined, startDate: Date | null | undefined, endDate: Date | null | undefined): Promise<PagedResultOfNotification> {
        let url_ = this.baseUrl + "/api/notifications?";
        if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&"; 
        if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&"; 
        if (type !== undefined)
            url_ += "Type=" + encodeURIComponent("" + type) + "&"; 
        if (title !== undefined)
            url_ += "Title=" + encodeURIComponent("" + title) + "&"; 
        if (body !== undefined)
            url_ += "Body=" + encodeURIComponent("" + body) + "&"; 
        if (targetRetailerId !== undefined)
            url_ += "TargetRetailerId=" + encodeURIComponent("" + targetRetailerId) + "&"; 
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<PagedResultOfNotification> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultOfNotification.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultOfNotification>(<any>null);
    }

    /**
     * All Alerts
     */
    getStrippedNotifications(): Promise<IdValueDtoOfGuid[]> {
        let url_ = this.baseUrl + "/api/notifications/stripped";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGetStrippedNotifications(_response);
        });
    }

    protected processGetStrippedNotifications(response: AxiosResponse): Promise<IdValueDtoOfGuid[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(IdValueDtoOfGuid.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<IdValueDtoOfGuid[]>(<any>null);
    }

    /**
     * Delete a Notification
     */
    delete(id: string): Promise<Unit> {
        let url_ = this.baseUrl + "/api/notifications/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<Unit> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Unit.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Unit>(<any>null);
    }
}

export interface IRequestsClient {
    /**
     * Get Requests list
     * @param page (optional) 
     * @param size (optional) 
     * @param requestObject (optional) 
     * @param requestCategoryId (optional) 
     * @param requestNature (optional) 
     * @param processingDirection (optional) 
     * @param lastStatus (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param retailer (optional) 
     * @param requestAssignedTo (optional) 
     * @param firstName (optional) 
     * @param lastName (optional) 
     * @param phone (optional) 
     * @param isNotified (optional) 
     */
    get(page: number | null | undefined, size: number | null | undefined, requestObject: string | null | undefined, requestCategoryId: string | null | undefined, requestNature: RequestNatureType | null | undefined, processingDirection: ProcessingDirectionType | null | undefined, lastStatus: RequestStatusType | null | undefined, startDate: Date | null | undefined, endDate: Date | null | undefined, retailer: string | null | undefined, requestAssignedTo: (RequestAffectationType | undefined)[] | null | undefined, firstName: string | null | undefined, lastName: string | null | undefined, phone: string | null | undefined, isNotified: boolean | null | undefined): Promise<PagedResultOfRequest>;
    /**
     * Create new request
     * @param vm request data
     * @return Created request object
     */
    create(vm: RequestVm): Promise<Request>;
    /**
     * Get Request by id
     */
    getById(id: string): Promise<Request>;
    /**
     * contest request by retailer
     */
    contest(id: string, reason: string): Promise<Unit>;
    /**
     * Cancel request by retailer
     */
    cancel(id: string, reason: string): Promise<Unit>;
    /**
     * RequestComment by Id
     */
    getCommentsById(id: string): Promise<RequestComment[]>;
}

export class RequestsClient implements IRequestsClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * Get Requests list
     * @param page (optional) 
     * @param size (optional) 
     * @param requestObject (optional) 
     * @param requestCategoryId (optional) 
     * @param requestNature (optional) 
     * @param processingDirection (optional) 
     * @param lastStatus (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param retailer (optional) 
     * @param requestAssignedTo (optional) 
     * @param firstName (optional) 
     * @param lastName (optional) 
     * @param phone (optional) 
     * @param isNotified (optional) 
     */
    get(page: number | null | undefined, size: number | null | undefined, requestObject: string | null | undefined, requestCategoryId: string | null | undefined, requestNature: RequestNatureType | null | undefined, processingDirection: ProcessingDirectionType | null | undefined, lastStatus: RequestStatusType | null | undefined, startDate: Date | null | undefined, endDate: Date | null | undefined, retailer: string | null | undefined, requestAssignedTo: (RequestAffectationType | undefined)[] | null | undefined, firstName: string | null | undefined, lastName: string | null | undefined, phone: string | null | undefined, isNotified: boolean | null | undefined): Promise<PagedResultOfRequest> {
        let url_ = this.baseUrl + "/requests?";
        if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&"; 
        if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&"; 
        if (requestObject !== undefined)
            url_ += "RequestObject=" + encodeURIComponent("" + requestObject) + "&"; 
        if (requestCategoryId !== undefined)
            url_ += "RequestCategoryId=" + encodeURIComponent("" + requestCategoryId) + "&"; 
        if (requestNature !== undefined)
            url_ += "RequestNature=" + encodeURIComponent("" + requestNature) + "&"; 
        if (processingDirection !== undefined)
            url_ += "ProcessingDirection=" + encodeURIComponent("" + processingDirection) + "&"; 
        if (lastStatus !== undefined)
            url_ += "LastStatus=" + encodeURIComponent("" + lastStatus) + "&"; 
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (retailer !== undefined)
            url_ += "Retailer=" + encodeURIComponent("" + retailer) + "&"; 
        if (requestAssignedTo !== undefined)
            requestAssignedTo && requestAssignedTo.forEach(item => { url_ += "RequestAssignedTo=" + encodeURIComponent("" + item) + "&"; });
        if (firstName !== undefined)
            url_ += "FirstName=" + encodeURIComponent("" + firstName) + "&"; 
        if (lastName !== undefined)
            url_ += "LastName=" + encodeURIComponent("" + lastName) + "&"; 
        if (phone !== undefined)
            url_ += "Phone=" + encodeURIComponent("" + phone) + "&"; 
        if (isNotified !== undefined)
            url_ += "IsNotified=" + encodeURIComponent("" + isNotified) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<PagedResultOfRequest> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultOfRequest.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultOfRequest>(<any>null);
    }

    /**
     * Create new request
     * @param vm request data
     * @return Created request object
     */
    create(vm: RequestVm): Promise<Request> {
        let url_ = this.baseUrl + "/requests";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(vm);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<Request> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Request.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Request>(<any>null);
    }

    /**
     * Get Request by id
     */
    getById(id: string): Promise<Request> {
        let url_ = this.baseUrl + "/requests/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: AxiosResponse): Promise<Request> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Request.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Request>(<any>null);
    }

    /**
     * contest request by retailer
     */
    contest(id: string, reason: string): Promise<Unit> {
        let url_ = this.baseUrl + "/requests/{id}/contest";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(reason);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processContest(_response);
        });
    }

    protected processContest(response: AxiosResponse): Promise<Unit> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Unit.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Unit>(<any>null);
    }

    /**
     * Cancel request by retailer
     */
    cancel(id: string, reason: string): Promise<Unit> {
        let url_ = this.baseUrl + "/requests/{id}/cancel";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(reason);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processCancel(_response);
        });
    }

    protected processCancel(response: AxiosResponse): Promise<Unit> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Unit.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Unit>(<any>null);
    }

    /**
     * RequestComment by Id
     */
    getCommentsById(id: string): Promise<RequestComment[]> {
        let url_ = this.baseUrl + "/requests/{Id}/comments";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{Id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGetCommentsById(_response);
        });
    }

    protected processGetCommentsById(response: AxiosResponse): Promise<RequestComment[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RequestComment.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RequestComment[]>(<any>null);
    }
}

export interface IRetailersClient {
    /**
     * Get Current Retailer
     */
    getCurrentRetailer(): Promise<RetailerDetailsDto>;
    /**
     * Get Retailer Agent
     */
    getAgent(): Promise<User>;
    /**
     * Activates notifications for a retailer
     */
    activateNotification(deviceToken: string): Promise<Unit>;
    /**
     * deactivates notifications for a retailer
     */
    deactivateNotification(deviceToken: string): Promise<Unit>;
    /**
     * Get Retailer documents
     * @param type (optional) 
     */
    getDocuments(id: string, type: DocumentType | null | undefined): Promise<DocumentDto[]>;
    /**
     * Get Notifications from current retailer
     */
    getNotifications(): Promise<PagedResultOfNotification>;
    /**
     * Get Notifications from current retailer
     */
    getStrippedNotifications(): Promise<IdValueDtoOfGuid[]>;
}

export class RetailersClient implements IRetailersClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * Get Current Retailer
     */
    getCurrentRetailer(): Promise<RetailerDetailsDto> {
        let url_ = this.baseUrl + "/api/retailers/current";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGetCurrentRetailer(_response);
        });
    }

    protected processGetCurrentRetailer(response: AxiosResponse): Promise<RetailerDetailsDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = RetailerDetailsDto.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RetailerDetailsDto>(<any>null);
    }

    /**
     * Get Retailer Agent
     */
    getAgent(): Promise<User> {
        let url_ = this.baseUrl + "/api/retailers/agent";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGetAgent(_response);
        });
    }

    protected processGetAgent(response: AxiosResponse): Promise<User> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = User.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<User>(<any>null);
    }

    /**
     * Activates notifications for a retailer
     */
    activateNotification(deviceToken: string): Promise<Unit> {
        let url_ = this.baseUrl + "/api/retailers/notifications/activate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(deviceToken);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processActivateNotification(_response);
        });
    }

    protected processActivateNotification(response: AxiosResponse): Promise<Unit> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Unit.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Unit>(<any>null);
    }

    /**
     * deactivates notifications for a retailer
     */
    deactivateNotification(deviceToken: string): Promise<Unit> {
        let url_ = this.baseUrl + "/api/retailers/notifications/deactivate";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(deviceToken);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processDeactivateNotification(_response);
        });
    }

    protected processDeactivateNotification(response: AxiosResponse): Promise<Unit> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Unit.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Unit>(<any>null);
    }

    /**
     * Get Retailer documents
     * @param type (optional) 
     */
    getDocuments(id: string, type: DocumentType | null | undefined): Promise<DocumentDto[]> {
        let url_ = this.baseUrl + "/api/retailers/{id}/documents?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        if (type !== undefined)
            url_ += "type=" + encodeURIComponent("" + type) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGetDocuments(_response);
        });
    }

    protected processGetDocuments(response: AxiosResponse): Promise<DocumentDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(DocumentDto.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DocumentDto[]>(<any>null);
    }

    /**
     * Get Notifications from current retailer
     */
    getNotifications(): Promise<PagedResultOfNotification> {
        let url_ = this.baseUrl + "/api/retailers/notifications";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGetNotifications(_response);
        });
    }

    protected processGetNotifications(response: AxiosResponse): Promise<PagedResultOfNotification> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultOfNotification.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultOfNotification>(<any>null);
    }

    /**
     * Get Notifications from current retailer
     */
    getStrippedNotifications(): Promise<IdValueDtoOfGuid[]> {
        let url_ = this.baseUrl + "/api/retailers/notifications/stripped";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGetStrippedNotifications(_response);
        });
    }

    protected processGetStrippedNotifications(response: AxiosResponse): Promise<IdValueDtoOfGuid[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(IdValueDtoOfGuid.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<IdValueDtoOfGuid[]>(<any>null);
    }
}

export interface ITrainingModulesClient {
    /**
     * List all TrainingModules
     */
    get(): Promise<TrainingModuleDTO[]>;
    /**
     * List stripped TrainingModules
     */
    getStripped(): Promise<IdValueDtoOfGuid[]>;
    /**
     * List TrainingModule by id
     */
    getById(id: string): Promise<TrainingModule>;
}

export class TrainingModulesClient implements ITrainingModulesClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * List all TrainingModules
     */
    get(): Promise<TrainingModuleDTO[]> {
        let url_ = this.baseUrl + "/api/trainingmodules";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<TrainingModuleDTO[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TrainingModuleDTO.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TrainingModuleDTO[]>(<any>null);
    }

    /**
     * List stripped TrainingModules
     */
    getStripped(): Promise<IdValueDtoOfGuid[]> {
        let url_ = this.baseUrl + "/api/trainingmodules/stripped";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGetStripped(_response);
        });
    }

    protected processGetStripped(response: AxiosResponse): Promise<IdValueDtoOfGuid[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(IdValueDtoOfGuid.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<IdValueDtoOfGuid[]>(<any>null);
    }

    /**
     * List TrainingModule by id
     */
    getById(id: string): Promise<TrainingModule> {
        let url_ = this.baseUrl + "/api/trainingmodules/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: AxiosResponse): Promise<TrainingModule> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TrainingModule.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TrainingModule>(<any>null);
    }
}

export interface ITrainingsClient {
    /**
     * Get Trainings list
     * @param page (optional) 
     * @param size (optional) 
     * @param minStartDate (optional) 
     * @param maxStartDate (optional) 
     * @param maxEndDate (optional) 
     * @param minEndDate (optional) 
     * @param trainingType (optional) 
     * @param filter (optional) 
     * @param moduleId (optional) 
     */
    get(page: number | null | undefined, size: number | null | undefined, minStartDate: Date | null | undefined, maxStartDate: Date | null | undefined, maxEndDate: Date | null | undefined, minEndDate: Date | null | undefined, trainingType: TrainingType | null | undefined, filter: string | null | undefined, moduleId: string | null | undefined): Promise<TrainingVm[]>;
    /**
     * Get Training by id
     */
    getById(id: string): Promise<Training>;
    /**
     * Get Training by id
     */
    getTrainingQuestionsById(id: string): Promise<TrainingQuestion[]>;
    /**
     * Get Training slides by id
     */
    getTrainingSlidesById(id: string): Promise<InteractiveTrainingDocumentVm>;
    /**
     * Start Training
     */
    start(id: string): Promise<Unit>;
    /**
     * Finish Training
     */
    finish(id: string): Promise<Unit>;
    /**
     * Finish Test
     */
    complete(id: string, optionIDs: string[]): Promise<CompleteTrainingVm>;
}

export class TrainingsClient implements ITrainingsClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * Get Trainings list
     * @param page (optional) 
     * @param size (optional) 
     * @param minStartDate (optional) 
     * @param maxStartDate (optional) 
     * @param maxEndDate (optional) 
     * @param minEndDate (optional) 
     * @param trainingType (optional) 
     * @param filter (optional) 
     * @param moduleId (optional) 
     */
    get(page: number | null | undefined, size: number | null | undefined, minStartDate: Date | null | undefined, maxStartDate: Date | null | undefined, maxEndDate: Date | null | undefined, minEndDate: Date | null | undefined, trainingType: TrainingType | null | undefined, filter: string | null | undefined, moduleId: string | null | undefined): Promise<TrainingVm[]> {
        let url_ = this.baseUrl + "/api/trainings?";
        if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&"; 
        if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&"; 
        if (minStartDate !== undefined)
            url_ += "MinStartDate=" + encodeURIComponent(minStartDate ? "" + minStartDate.toJSON() : "") + "&"; 
        if (maxStartDate !== undefined)
            url_ += "MaxStartDate=" + encodeURIComponent(maxStartDate ? "" + maxStartDate.toJSON() : "") + "&"; 
        if (maxEndDate !== undefined)
            url_ += "MaxEndDate=" + encodeURIComponent(maxEndDate ? "" + maxEndDate.toJSON() : "") + "&"; 
        if (minEndDate !== undefined)
            url_ += "MinEndDate=" + encodeURIComponent(minEndDate ? "" + minEndDate.toJSON() : "") + "&"; 
        if (trainingType !== undefined)
            url_ += "TrainingType=" + encodeURIComponent("" + trainingType) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (moduleId !== undefined)
            url_ += "ModuleId=" + encodeURIComponent("" + moduleId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<TrainingVm[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TrainingVm.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TrainingVm[]>(<any>null);
    }

    /**
     * Get Training by id
     */
    getById(id: string): Promise<Training> {
        let url_ = this.baseUrl + "/api/trainings/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: AxiosResponse): Promise<Training> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Training.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Training>(<any>null);
    }

    /**
     * Get Training by id
     */
    getTrainingQuestionsById(id: string): Promise<TrainingQuestion[]> {
        let url_ = this.baseUrl + "/api/trainings/{id}/questions";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGetTrainingQuestionsById(_response);
        });
    }

    protected processGetTrainingQuestionsById(response: AxiosResponse): Promise<TrainingQuestion[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TrainingQuestion.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TrainingQuestion[]>(<any>null);
    }

    /**
     * Get Training slides by id
     */
    getTrainingSlidesById(id: string): Promise<InteractiveTrainingDocumentVm> {
        let url_ = this.baseUrl + "/api/trainings/{id}/slides";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGetTrainingSlidesById(_response);
        });
    }

    protected processGetTrainingSlidesById(response: AxiosResponse): Promise<InteractiveTrainingDocumentVm> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = InteractiveTrainingDocumentVm.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<InteractiveTrainingDocumentVm>(<any>null);
    }

    /**
     * Start Training
     */
    start(id: string): Promise<Unit> {
        let url_ = this.baseUrl + "/api/trainings/{id}/course/start";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processStart(_response);
        });
    }

    protected processStart(response: AxiosResponse): Promise<Unit> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Unit.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Unit>(<any>null);
    }

    /**
     * Finish Training
     */
    finish(id: string): Promise<Unit> {
        let url_ = this.baseUrl + "/api/trainings/{id}/course/finish";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processFinish(_response);
        });
    }

    protected processFinish(response: AxiosResponse): Promise<Unit> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Unit.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Unit>(<any>null);
    }

    /**
     * Finish Test
     */
    complete(id: string, optionIDs: string[]): Promise<CompleteTrainingVm> {
        let url_ = this.baseUrl + "/api/trainings/{id}/test/finish";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(optionIDs);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processComplete(_response);
        });
    }

    protected processComplete(response: AxiosResponse): Promise<CompleteTrainingVm> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = CompleteTrainingVm.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<CompleteTrainingVm>(<any>null);
    }
}

export interface IUsersClient {
    /**
     * Get users list
     * @param page (optional) 
     * @param size (optional) 
     * @param userName (optional) 
     * @param email (optional) 
     * @param firstName (optional) 
     * @param lastName (optional) 
     * @param roleId (optional) 
     * @param isDeactivated (optional) 
     * @param roles (optional) 
     */
    get(page: number | null | undefined, size: number | null | undefined, userName: string | null | undefined, email: string | null | undefined, firstName: string | null | undefined, lastName: string | null | undefined, roleId: string | null | undefined, isDeactivated: boolean | null | undefined, roles: string[] | null | undefined): Promise<PagedResultOfUser>;
    /**
     * Get user by id
     */
    getById(id: string | null): Promise<User>;
    /**
     * Update user details
     */
    updateUser(id: string | null, userUpdateDto: UserUpdateDto): Promise<User>;
    /**
     * Get Users by role
     * @param rolenames (optional) User RoleName
     */
    getByRoles(rolenames: string[] | null | undefined): Promise<User[]>;
    /**
     * Get logged in user
     */
    getConnectedUser(): Promise<User>;
    /**
     * Changes usr passuser
     */
    changePassword(changePasswordData: ChangePasswordData): Promise<Unit>;
    /**
     * Init ForgotPassword
     */
    forgotPassword(phone: string): Promise<Unit>;
    /**
     * Reset Password
     * @param newPassword (optional) 
     * @param code (optional) 
     */
    resetPassword(newPassword: string | null | undefined, code: string | null | undefined): Promise<Unit>;
}

export class UsersClient implements IUsersClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * Get users list
     * @param page (optional) 
     * @param size (optional) 
     * @param userName (optional) 
     * @param email (optional) 
     * @param firstName (optional) 
     * @param lastName (optional) 
     * @param roleId (optional) 
     * @param isDeactivated (optional) 
     * @param roles (optional) 
     */
    get(page: number | null | undefined, size: number | null | undefined, userName: string | null | undefined, email: string | null | undefined, firstName: string | null | undefined, lastName: string | null | undefined, roleId: string | null | undefined, isDeactivated: boolean | null | undefined, roles: string[] | null | undefined): Promise<PagedResultOfUser> {
        let url_ = this.baseUrl + "/api/users?";
        if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&"; 
        if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&"; 
        if (userName !== undefined)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&"; 
        if (email !== undefined)
            url_ += "Email=" + encodeURIComponent("" + email) + "&"; 
        if (firstName !== undefined)
            url_ += "FirstName=" + encodeURIComponent("" + firstName) + "&"; 
        if (lastName !== undefined)
            url_ += "LastName=" + encodeURIComponent("" + lastName) + "&"; 
        if (roleId !== undefined)
            url_ += "RoleId=" + encodeURIComponent("" + roleId) + "&"; 
        if (isDeactivated !== undefined)
            url_ += "IsDeactivated=" + encodeURIComponent("" + isDeactivated) + "&"; 
        if (roles !== undefined)
            roles && roles.forEach(item => { url_ += "Roles=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<PagedResultOfUser> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultOfUser.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultOfUser>(<any>null);
    }

    /**
     * Get user by id
     */
    getById(id: string | null): Promise<User> {
        let url_ = this.baseUrl + "/api/users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: AxiosResponse): Promise<User> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = User.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<User>(<any>null);
    }

    /**
     * Update user details
     */
    updateUser(id: string | null, userUpdateDto: UserUpdateDto): Promise<User> {
        let url_ = this.baseUrl + "/api/users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(userUpdateDto);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processUpdateUser(_response);
        });
    }

    protected processUpdateUser(response: AxiosResponse): Promise<User> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = User.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<User>(<any>null);
    }

    /**
     * Get Users by role
     * @param rolenames (optional) User RoleName
     */
    getByRoles(rolenames: string[] | null | undefined): Promise<User[]> {
        let url_ = this.baseUrl + "/api/users/roles?";
        if (rolenames !== undefined)
            rolenames && rolenames.forEach(item => { url_ += "rolenames=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGetByRoles(_response);
        });
    }

    protected processGetByRoles(response: AxiosResponse): Promise<User[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(User.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<User[]>(<any>null);
    }

    /**
     * Get logged in user
     */
    getConnectedUser(): Promise<User> {
        let url_ = this.baseUrl + "/api/users/current";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGetConnectedUser(_response);
        });
    }

    protected processGetConnectedUser(response: AxiosResponse): Promise<User> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = User.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<User>(<any>null);
    }

    /**
     * Changes usr passuser
     */
    changePassword(changePasswordData: ChangePasswordData): Promise<Unit> {
        let url_ = this.baseUrl + "/api/users/password/change";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(changePasswordData);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processChangePassword(_response);
        });
    }

    protected processChangePassword(response: AxiosResponse): Promise<Unit> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Unit.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Unit>(<any>null);
    }

    /**
     * Init ForgotPassword
     */
    forgotPassword(phone: string): Promise<Unit> {
        let url_ = this.baseUrl + "/api/users/forgotpassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(phone);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processForgotPassword(_response);
        });
    }

    protected processForgotPassword(response: AxiosResponse): Promise<Unit> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Unit.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Unit>(<any>null);
    }

    /**
     * Reset Password
     * @param newPassword (optional) 
     * @param code (optional) 
     */
    resetPassword(newPassword: string | null | undefined, code: string | null | undefined): Promise<Unit> {
        let url_ = this.baseUrl + "/api/users/resetpassword?";
        if (newPassword !== undefined)
            url_ += "newPassword=" + encodeURIComponent("" + newPassword) + "&"; 
        if (code !== undefined)
            url_ += "code=" + encodeURIComponent("" + code) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processResetPassword(_response);
        });
    }

    protected processResetPassword(response: AxiosResponse): Promise<Unit> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Unit.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Unit>(<any>null);
    }
}

export interface IResourcesClient {
    get(): Promise<{ [key: string]: { [key: string]: string; }; }>;
}

export class ResourcesClient implements IResourcesClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    get(): Promise<{ [key: string]: { [key: string]: string; }; }> {
        let url_ = this.baseUrl + "/api/resources";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<{ [key: string]: { [key: string]: string; }; }> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200![key] = resultData200[key] !== undefined ? resultData200[key] : {};
                }
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<{ [key: string]: { [key: string]: string; }; }>(<any>null);
    }
}

export abstract class PagedResultBase implements IPagedResultBase {
    currentPage?: number;
    pageCount?: number;
    pageSize?: number;
    rowCount?: number;
    firstRowOnPage?: number;
    lastRowOnPage?: number;

    constructor(data?: IPagedResultBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currentPage = _data["currentPage"];
            this.pageCount = _data["pageCount"];
            this.pageSize = _data["pageSize"];
            this.rowCount = _data["rowCount"];
            this.firstRowOnPage = _data["firstRowOnPage"];
            this.lastRowOnPage = _data["lastRowOnPage"];
        }
    }

    static fromJS(data: any): PagedResultBase {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'PagedResultBase' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentPage"] = this.currentPage;
        data["pageCount"] = this.pageCount;
        data["pageSize"] = this.pageSize;
        data["rowCount"] = this.rowCount;
        data["firstRowOnPage"] = this.firstRowOnPage;
        data["lastRowOnPage"] = this.lastRowOnPage;
        return data; 
    }
}

export interface IPagedResultBase {
    currentPage?: number;
    pageCount?: number;
    pageSize?: number;
    rowCount?: number;
    firstRowOnPage?: number;
    lastRowOnPage?: number;
}

export class PagedResultOfRequestObject extends PagedResultBase implements IPagedResultOfRequestObject {
    results?: RequestObject[] | undefined;

    constructor(data?: IPagedResultOfRequestObject) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(RequestObject.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultOfRequestObject {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfRequestObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IPagedResultOfRequestObject extends IPagedResultBase {
    results?: RequestObject[] | undefined;
}

export abstract class IdBasedEntityOfGuid implements IIdBasedEntityOfGuid {
    id?: string;

    constructor(data?: IIdBasedEntityOfGuid) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): IdBasedEntityOfGuid {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'IdBasedEntityOfGuid' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface IIdBasedEntityOfGuid {
    id?: string;
}

export abstract class BaseEntityOfGuid extends IdBasedEntityOfGuid implements IBaseEntityOfGuid {
    created?: Date;
    lastModified?: Date | undefined;
    createdBy?: string | undefined;
    lastModifiedBy?: string | undefined;
    isDeleted?: boolean | undefined;

    constructor(data?: IBaseEntityOfGuid) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.lastModified = _data["lastModified"] ? new Date(_data["lastModified"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.lastModifiedBy = _data["lastModifiedBy"];
            this.isDeleted = _data["isDeleted"];
        }
    }

    static fromJS(data: any): BaseEntityOfGuid {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'BaseEntityOfGuid' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["lastModified"] = this.lastModified ? this.lastModified.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["lastModifiedBy"] = this.lastModifiedBy;
        data["isDeleted"] = this.isDeleted;
        super.toJSON(data);
        return data; 
    }
}

export interface IBaseEntityOfGuid extends IIdBasedEntityOfGuid {
    created?: Date;
    lastModified?: Date | undefined;
    createdBy?: string | undefined;
    lastModifiedBy?: string | undefined;
    isDeleted?: boolean | undefined;
}

export abstract class AbstractDocument extends BaseEntityOfGuid implements IAbstractDocument {
    uri?: string | undefined;
    data?: string | undefined;
    mimeType?: string | undefined;
    isGenerated?: boolean | undefined;
    type?: DocumentType;
    spec?: DocumentSpec;
    comment?: string | undefined;

    constructor(data?: IAbstractDocument) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.uri = _data["uri"];
            this.data = _data["data"];
            this.mimeType = _data["mimeType"];
            this.isGenerated = _data["isGenerated"];
            this.type = _data["type"];
            this.spec = _data["spec"];
            this.comment = _data["comment"];
        }
    }

    static fromJS(data: any): AbstractDocument {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'AbstractDocument' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["uri"] = this.uri;
        data["data"] = this.data;
        data["mimeType"] = this.mimeType;
        data["isGenerated"] = this.isGenerated;
        data["type"] = this.type;
        data["spec"] = this.spec;
        data["comment"] = this.comment;
        super.toJSON(data);
        return data; 
    }
}

export interface IAbstractDocument extends IBaseEntityOfGuid {
    uri?: string | undefined;
    data?: string | undefined;
    mimeType?: string | undefined;
    isGenerated?: boolean | undefined;
    type?: DocumentType;
    spec?: DocumentSpec;
    comment?: string | undefined;
}

export class RequestObject extends AbstractDocument implements IRequestObject {
    title?: string | undefined;
    isExternal?: boolean | undefined;
    isDeactivated?: boolean;
    requestCategory?: RequestCategory | undefined;
    requestCategoryId?: string;
    processingDirection?: ProcessingDirectionType | undefined;

    constructor(data?: IRequestObject) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.title = _data["title"];
            this.isExternal = _data["isExternal"];
            this.isDeactivated = _data["isDeactivated"];
            this.requestCategory = _data["requestCategory"] ? RequestCategory.fromJS(_data["requestCategory"]) : <any>undefined;
            this.requestCategoryId = _data["requestCategoryId"];
            this.processingDirection = _data["processingDirection"];
        }
    }

    static fromJS(data: any): RequestObject {
        data = typeof data === 'object' ? data : {};
        let result = new RequestObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["isExternal"] = this.isExternal;
        data["isDeactivated"] = this.isDeactivated;
        data["requestCategory"] = this.requestCategory ? this.requestCategory.toJSON() : <any>undefined;
        data["requestCategoryId"] = this.requestCategoryId;
        data["processingDirection"] = this.processingDirection;
        super.toJSON(data);
        return data; 
    }
}

export interface IRequestObject extends IAbstractDocument {
    title?: string | undefined;
    isExternal?: boolean | undefined;
    isDeactivated?: boolean;
    requestCategory?: RequestCategory | undefined;
    requestCategoryId?: string;
    processingDirection?: ProcessingDirectionType | undefined;
}

export class RequestCategory extends AbstractDocument implements IRequestCategory {
    requestObjects?: RequestObject[] | undefined;
    title?: string | undefined;
    isDeactivated?: boolean;
    requestNature?: RequestNatureType;

    constructor(data?: IRequestCategory) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["requestObjects"])) {
                this.requestObjects = [] as any;
                for (let item of _data["requestObjects"])
                    this.requestObjects!.push(RequestObject.fromJS(item));
            }
            this.title = _data["title"];
            this.isDeactivated = _data["isDeactivated"];
            this.requestNature = _data["requestNature"];
        }
    }

    static fromJS(data: any): RequestCategory {
        data = typeof data === 'object' ? data : {};
        let result = new RequestCategory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.requestObjects)) {
            data["requestObjects"] = [];
            for (let item of this.requestObjects)
                data["requestObjects"].push(item.toJSON());
        }
        data["title"] = this.title;
        data["isDeactivated"] = this.isDeactivated;
        data["requestNature"] = this.requestNature;
        super.toJSON(data);
        return data; 
    }
}

export interface IRequestCategory extends IAbstractDocument {
    requestObjects?: RequestObject[] | undefined;
    title?: string | undefined;
    isDeactivated?: boolean;
    requestNature?: RequestNatureType;
}

export enum RequestNatureType {
    Technical = "Technical",
    Administration = "Administration",
    Sales = "Sales",
}

export enum DocumentType {
    TrainingCourseSlide = "TrainingCourseSlide",
    TrainingSupportFile = "TrainingSupportFile",
    TrainingCoverPicture = "TrainingCoverPicture",
    AnnouncementCoverPicture = "AnnouncementCoverPicture",
    OfficialDocument = "OfficialDocument",
    OfficialRessource = "OfficialRessource",
    RequestAudioDocument = "RequestAudioDocument",
    RequestPdfDocument = "RequestPdfDocument",
    RequestImageDocument = "RequestImageDocument",
    RequestObjectCoverPicture = "RequestObjectCoverPicture",
    RequestCategoryCoverPicture = "RequestCategoryCoverPicture",
    RequestNatureCoverPicture = "RequestNatureCoverPicture",
    TrainingCertificate = "TrainingCertificate",
    MediaLibraryDocument = "MediaLibraryDocument",
    ToolboxDocument = "ToolboxDocument",
}

export enum DocumentSpec {
    None = "None",
    AutoGenerated = "AutoGenerated",
    PaperWork = "PaperWork",
}

export enum ProcessingDirectionType {
    DCO = "DCO",
    DMD = "DMD",
    DFS = "DFS",
    DCPRM = "DCPRM",
}

export class IdValueDtoOfGuid implements IIdValueDtoOfGuid {
    id?: string;
    value?: string | undefined;

    constructor(data?: IIdValueDtoOfGuid) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): IdValueDtoOfGuid {
        data = typeof data === 'object' ? data : {};
        let result = new IdValueDtoOfGuid();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["value"] = this.value;
        return data; 
    }
}

export interface IIdValueDtoOfGuid {
    id?: string;
    value?: string | undefined;
}

export class PagedResultOfApplicationDocument extends PagedResultBase implements IPagedResultOfApplicationDocument {
    results?: ApplicationDocument[] | undefined;

    constructor(data?: IPagedResultOfApplicationDocument) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(ApplicationDocument.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultOfApplicationDocument {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfApplicationDocument();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IPagedResultOfApplicationDocument extends IPagedResultBase {
    results?: ApplicationDocument[] | undefined;
}

export class ApplicationDocument extends AbstractDocument implements IApplicationDocument {
    title?: string | undefined;

    constructor(data?: IApplicationDocument) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.title = _data["title"];
        }
    }

    static fromJS(data: any): ApplicationDocument {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationDocument();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        super.toJSON(data);
        return data; 
    }
}

export interface IApplicationDocument extends IAbstractDocument {
    title?: string | undefined;
}

export class PagedResultOfRequestCategory extends PagedResultBase implements IPagedResultOfRequestCategory {
    results?: RequestCategory[] | undefined;

    constructor(data?: IPagedResultOfRequestCategory) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(RequestCategory.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultOfRequestCategory {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfRequestCategory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IPagedResultOfRequestCategory extends IPagedResultBase {
    results?: RequestCategory[] | undefined;
}

export class PagedResultOfAnnouncement extends PagedResultBase implements IPagedResultOfAnnouncement {
    results?: Announcement[] | undefined;

    constructor(data?: IPagedResultOfAnnouncement) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(Announcement.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultOfAnnouncement {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfAnnouncement();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IPagedResultOfAnnouncement extends IPagedResultBase {
    results?: Announcement[] | undefined;
}

export class Announcement extends AbstractDocument implements IAnnouncement {
    title?: string | undefined;
    body?: string | undefined;
    isPublished?: boolean;

    constructor(data?: IAnnouncement) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.title = _data["title"];
            this.body = _data["body"];
            this.isPublished = _data["isPublished"];
        }
    }

    static fromJS(data: any): Announcement {
        data = typeof data === 'object' ? data : {};
        let result = new Announcement();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["body"] = this.body;
        data["isPublished"] = this.isPublished;
        super.toJSON(data);
        return data; 
    }
}

export interface IAnnouncement extends IAbstractDocument {
    title?: string | undefined;
    body?: string | undefined;
    isPublished?: boolean;
}

export class AuthenticationResult implements IAuthenticationResult {
    succeeded?: boolean;
    isLockedOut?: boolean;
    isNotAllowed?: boolean;
    accessToken?: string | undefined;
    isTemporaryPassword?: boolean;
    errors?: string[] | undefined;

    constructor(data?: IAuthenticationResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.succeeded = _data["succeeded"];
            this.isLockedOut = _data["isLockedOut"];
            this.isNotAllowed = _data["isNotAllowed"];
            this.accessToken = _data["accessToken"];
            this.isTemporaryPassword = _data["isTemporaryPassword"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): AuthenticationResult {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticationResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["succeeded"] = this.succeeded;
        data["isLockedOut"] = this.isLockedOut;
        data["isNotAllowed"] = this.isNotAllowed;
        data["accessToken"] = this.accessToken;
        data["isTemporaryPassword"] = this.isTemporaryPassword;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data; 
    }
}

export interface IAuthenticationResult {
    succeeded?: boolean;
    isLockedOut?: boolean;
    isNotAllowed?: boolean;
    accessToken?: string | undefined;
    isTemporaryPassword?: boolean;
    errors?: string[] | undefined;
}

export class UserSignInDto implements IUserSignInDto {
    userName!: string;
    password!: string;
    deviceToken?: string | undefined;

    constructor(data?: IUserSignInDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.password = _data["password"];
            this.deviceToken = _data["deviceToken"];
        }
    }

    static fromJS(data: any): UserSignInDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserSignInDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["password"] = this.password;
        data["deviceToken"] = this.deviceToken;
        return data; 
    }
}

export interface IUserSignInDto {
    userName: string;
    password: string;
    deviceToken?: string | undefined;
}

export enum GameType {
    Loto = "Loto",
    Joker = "Joker",
    Keno = "Keno",
    Quatro = "Quatro",
}

export class DocumentDto implements IDocumentDto {
    id?: string | undefined;
    type?: DocumentType;
    spec?: DocumentSpec;
    mimeType?: string | undefined;
    created?: Date;
    comment?: string | undefined;

    constructor(data?: IDocumentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.type = _data["type"];
            this.spec = _data["spec"];
            this.mimeType = _data["mimeType"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.comment = _data["comment"];
        }
    }

    static fromJS(data: any): DocumentDto {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["type"] = this.type;
        data["spec"] = this.spec;
        data["mimeType"] = this.mimeType;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["comment"] = this.comment;
        return data; 
    }
}

export interface IDocumentDto {
    id?: string | undefined;
    type?: DocumentType;
    spec?: DocumentSpec;
    mimeType?: string | undefined;
    created?: Date;
    comment?: string | undefined;
}

export class ExcellenceProgramDto implements IExcellenceProgramDto {
    ca?: number;
    classification?: string | undefined;
    loyaltyPoints?: number;

    constructor(data?: IExcellenceProgramDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.ca = _data["ca"];
            this.classification = _data["classification"];
            this.loyaltyPoints = _data["loyaltyPoints"];
        }
    }

    static fromJS(data: any): ExcellenceProgramDto {
        data = typeof data === 'object' ? data : {};
        let result = new ExcellenceProgramDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["ca"] = this.ca;
        data["classification"] = this.classification;
        data["loyaltyPoints"] = this.loyaltyPoints;
        return data; 
    }
}

export interface IExcellenceProgramDto {
    ca?: number;
    classification?: string | undefined;
    loyaltyPoints?: number;
}

export class IncentiveDto implements IIncentiveDto {
    type?: GameType;
    startDate?: string | undefined;
    endDate?: string | undefined;
    goal?: number;
    achievement?: number;
    achievementRate?: number;
    remains?: number;
    bonus?: number;

    constructor(data?: IIncentiveDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.startDate = _data["startDate"];
            this.endDate = _data["endDate"];
            this.goal = _data["goal"];
            this.achievement = _data["achievement"];
            this.achievementRate = _data["achievementRate"];
            this.remains = _data["remains"];
            this.bonus = _data["bonus"];
        }
    }

    static fromJS(data: any): IncentiveDto {
        data = typeof data === 'object' ? data : {};
        let result = new IncentiveDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["startDate"] = this.startDate;
        data["endDate"] = this.endDate;
        data["goal"] = this.goal;
        data["achievement"] = this.achievement;
        data["achievementRate"] = this.achievementRate;
        data["remains"] = this.remains;
        data["bonus"] = this.bonus;
        return data; 
    }
}

export interface IIncentiveDto {
    type?: GameType;
    startDate?: string | undefined;
    endDate?: string | undefined;
    goal?: number;
    achievement?: number;
    achievementRate?: number;
    remains?: number;
    bonus?: number;
}

export class InvoiceDto implements IInvoiceDto {
    reference?: string | undefined;
    status?: string | undefined;
    date?: Date;
    amount?: number;

    constructor(data?: IInvoiceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.reference = _data["reference"];
            this.status = _data["status"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.amount = _data["amount"];
        }
    }

    static fromJS(data: any): InvoiceDto {
        data = typeof data === 'object' ? data : {};
        let result = new InvoiceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reference"] = this.reference;
        data["status"] = this.status;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["amount"] = this.amount;
        return data; 
    }
}

export interface IInvoiceDto {
    reference?: string | undefined;
    status?: string | undefined;
    date?: Date;
    amount?: number;
}

export class StatusInvoiceDto implements IStatusInvoiceDto {
    paidAmountInvoicesLastSixMonths?: number;
    unPaidAmountInvoicesLastSixMonths?: number;
    monthlyReport?: MonthlyReportDto[] | undefined;

    constructor(data?: IStatusInvoiceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.paidAmountInvoicesLastSixMonths = _data["paidAmountInvoicesLastSixMonths"];
            this.unPaidAmountInvoicesLastSixMonths = _data["unPaidAmountInvoicesLastSixMonths"];
            if (Array.isArray(_data["monthlyReport"])) {
                this.monthlyReport = [] as any;
                for (let item of _data["monthlyReport"])
                    this.monthlyReport!.push(MonthlyReportDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): StatusInvoiceDto {
        data = typeof data === 'object' ? data : {};
        let result = new StatusInvoiceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["paidAmountInvoicesLastSixMonths"] = this.paidAmountInvoicesLastSixMonths;
        data["unPaidAmountInvoicesLastSixMonths"] = this.unPaidAmountInvoicesLastSixMonths;
        if (Array.isArray(this.monthlyReport)) {
            data["monthlyReport"] = [];
            for (let item of this.monthlyReport)
                data["monthlyReport"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IStatusInvoiceDto {
    paidAmountInvoicesLastSixMonths?: number;
    unPaidAmountInvoicesLastSixMonths?: number;
    monthlyReport?: MonthlyReportDto[] | undefined;
}

export class MonthlyReportDto implements IMonthlyReportDto {
    month?: string | undefined;
    year?: string | undefined;
    startDate?: Date;
    endDate?: Date;
    total?: number;
    unpaid?: number;

    constructor(data?: IMonthlyReportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.month = _data["month"];
            this.year = _data["year"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.total = _data["total"];
            this.unpaid = _data["unpaid"];
        }
    }

    static fromJS(data: any): MonthlyReportDto {
        data = typeof data === 'object' ? data : {};
        let result = new MonthlyReportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["month"] = this.month;
        data["year"] = this.year;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["total"] = this.total;
        data["unpaid"] = this.unpaid;
        return data; 
    }
}

export interface IMonthlyReportDto {
    month?: string | undefined;
    year?: string | undefined;
    startDate?: Date;
    endDate?: Date;
    total?: number;
    unpaid?: number;
}

export class LoyaltyPointsDto implements ILoyaltyPointsDto {
    loyaltyPoints?: number;
    countInvoices?: number;
    amountInvoices?: number;

    constructor(data?: ILoyaltyPointsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.loyaltyPoints = _data["loyaltyPoints"];
            this.countInvoices = _data["countInvoices"];
            this.amountInvoices = _data["amountInvoices"];
        }
    }

    static fromJS(data: any): LoyaltyPointsDto {
        data = typeof data === 'object' ? data : {};
        let result = new LoyaltyPointsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["loyaltyPoints"] = this.loyaltyPoints;
        data["countInvoices"] = this.countInvoices;
        data["amountInvoices"] = this.amountInvoices;
        return data; 
    }
}

export interface ILoyaltyPointsDto {
    loyaltyPoints?: number;
    countInvoices?: number;
    amountInvoices?: number;
}

export class PagedResultOfNotification extends PagedResultBase implements IPagedResultOfNotification {
    results?: Notification[] | undefined;

    constructor(data?: IPagedResultOfNotification) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(Notification.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultOfNotification {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfNotification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IPagedResultOfNotification extends IPagedResultBase {
    results?: Notification[] | undefined;
}

export class Notification extends BaseEntityOfGuid implements INotification {
    title?: string | undefined;
    body?: string | undefined;
    type?: NotificationType;
    targetScreen?: NotificationTargetType | undefined;
    targetId?: string | undefined;
    retailerNotifications?: RetailerNotification[] | undefined;

    constructor(data?: INotification) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.title = _data["title"];
            this.body = _data["body"];
            this.type = _data["type"];
            this.targetScreen = _data["targetScreen"];
            this.targetId = _data["targetId"];
            if (Array.isArray(_data["retailerNotifications"])) {
                this.retailerNotifications = [] as any;
                for (let item of _data["retailerNotifications"])
                    this.retailerNotifications!.push(RetailerNotification.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Notification {
        data = typeof data === 'object' ? data : {};
        let result = new Notification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["body"] = this.body;
        data["type"] = this.type;
        data["targetScreen"] = this.targetScreen;
        data["targetId"] = this.targetId;
        if (Array.isArray(this.retailerNotifications)) {
            data["retailerNotifications"] = [];
            for (let item of this.retailerNotifications)
                data["retailerNotifications"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface INotification extends IBaseEntityOfGuid {
    title?: string | undefined;
    body?: string | undefined;
    type?: NotificationType;
    targetScreen?: NotificationTargetType | undefined;
    targetId?: string | undefined;
    retailerNotifications?: RetailerNotification[] | undefined;
}

export enum NotificationType {
    Notification = "Notification",
    Alert = "Alert",
}

export enum NotificationTargetType {
    RequestListScreen = "RequestListScreen",
    CreateRequestScreen = "CreateRequestScreen",
    NewsConsultationList = "NewsConsultationList",
    AnnoucementsDetails = "AnnoucementsDetails",
    TrainingAreaScreen = "TrainingAreaScreen",
    MediaLibraryDocumentScreen = "MediaLibraryDocumentScreen",
    ProfileScreen = "ProfileScreen",
    DocumentsScreen = "DocumentsScreen",
}

export class RetailerNotification implements IRetailerNotification {
    retailer?: Retailer | undefined;
    retailerId?: string;
    notification?: Notification | undefined;
    notificationId?: string;

    constructor(data?: IRetailerNotification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.retailer = _data["retailer"] ? Retailer.fromJS(_data["retailer"]) : <any>undefined;
            this.retailerId = _data["retailerId"];
            this.notification = _data["notification"] ? Notification.fromJS(_data["notification"]) : <any>undefined;
            this.notificationId = _data["notificationId"];
        }
    }

    static fromJS(data: any): RetailerNotification {
        data = typeof data === 'object' ? data : {};
        let result = new RetailerNotification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["retailer"] = this.retailer ? this.retailer.toJSON() : <any>undefined;
        data["retailerId"] = this.retailerId;
        data["notification"] = this.notification ? this.notification.toJSON() : <any>undefined;
        data["notificationId"] = this.notificationId;
        return data; 
    }
}

export interface IRetailerNotification {
    retailer?: Retailer | undefined;
    retailerId?: string;
    notification?: Notification | undefined;
    notificationId?: string;
}

export abstract class ContactBasedEntity extends BaseEntityOfGuid implements IContactBasedEntity {
    city?: string | undefined;
    address?: string | undefined;
    addressLine2?: string | undefined;
    zip?: string | undefined;
    phone?: string | undefined;
    email?: string | undefined;

    constructor(data?: IContactBasedEntity) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.city = _data["city"];
            this.address = _data["address"];
            this.addressLine2 = _data["addressLine2"];
            this.zip = _data["zip"];
            this.phone = _data["phone"];
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): ContactBasedEntity {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'ContactBasedEntity' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["city"] = this.city;
        data["address"] = this.address;
        data["addressLine2"] = this.addressLine2;
        data["zip"] = this.zip;
        data["phone"] = this.phone;
        data["email"] = this.email;
        super.toJSON(data);
        return data; 
    }
}

export interface IContactBasedEntity extends IBaseEntityOfGuid {
    city?: string | undefined;
    address?: string | undefined;
    addressLine2?: string | undefined;
    zip?: string | undefined;
    phone?: string | undefined;
    email?: string | undefined;
}

export class Retailer extends ContactBasedEntity implements IRetailer {
    civility?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    userId?: string | undefined;
    agentId?: string | undefined;
    internalRetailerCode?: string | undefined;
    externalRetailerCode?: string | undefined;
    currentBalance?: number;
    weeklySalesLimit?: number;
    annualCA?: number;
    totalCommissions?: number;
    totalUnpaid?: number;
    contractNumber?: string | undefined;
    companyIdentifier?: string | undefined;
    activity?: string | undefined;
    geographicSector?: string | undefined;
    adressLatitude?: number;
    adressLongitude?: number;
    isNotified?: boolean;
    tradeRegister?: string | undefined;
    professionalTax?: string | undefined;
    gpsCoordinates?: string | undefined;
    commercialZone?: string | undefined;
    geoCodeHCP?: string | undefined;
    municipality?: string | undefined;
    administrativeRegion?: string | undefined;
    sglnCommercialName?: string | undefined;
    sglnCommercialPhone?: string | undefined;
    sglnCommercialMail?: string | undefined;
    taxIdentification?: string | undefined;
    sisalCommercialName?: string | undefined;
    sisalCommercialMail?: string | undefined;
    sisalCommercialPhone?: string | undefined;
    weeksNumber?: number;
    classification?: string | undefined;
    loyalityPoints?: number;
    isDeactivated?: boolean;
    documents?: RetailerDocument[] | undefined;
    invoices?: Invoice[] | undefined;
    retailerNotifications?: RetailerNotification[] | undefined;

    constructor(data?: IRetailer) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.civility = _data["civility"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.userId = _data["userId"];
            this.agentId = _data["agentId"];
            this.internalRetailerCode = _data["internalRetailerCode"];
            this.externalRetailerCode = _data["externalRetailerCode"];
            this.currentBalance = _data["currentBalance"];
            this.weeklySalesLimit = _data["weeklySalesLimit"];
            this.annualCA = _data["annualCA"];
            this.totalCommissions = _data["totalCommissions"];
            this.totalUnpaid = _data["totalUnpaid"];
            this.contractNumber = _data["contractNumber"];
            this.companyIdentifier = _data["companyIdentifier"];
            this.activity = _data["activity"];
            this.geographicSector = _data["geographicSector"];
            this.adressLatitude = _data["adressLatitude"];
            this.adressLongitude = _data["adressLongitude"];
            this.isNotified = _data["isNotified"];
            this.tradeRegister = _data["tradeRegister"];
            this.professionalTax = _data["professionalTax"];
            this.gpsCoordinates = _data["gpsCoordinates"];
            this.commercialZone = _data["commercialZone"];
            this.geoCodeHCP = _data["geoCodeHCP"];
            this.municipality = _data["municipality"];
            this.administrativeRegion = _data["administrativeRegion"];
            this.sglnCommercialName = _data["sglnCommercialName"];
            this.sglnCommercialPhone = _data["sglnCommercialPhone"];
            this.sglnCommercialMail = _data["sglnCommercialMail"];
            this.taxIdentification = _data["taxIdentification"];
            this.sisalCommercialName = _data["sisalCommercialName"];
            this.sisalCommercialMail = _data["sisalCommercialMail"];
            this.sisalCommercialPhone = _data["sisalCommercialPhone"];
            this.weeksNumber = _data["weeksNumber"];
            this.classification = _data["classification"];
            this.loyalityPoints = _data["loyalityPoints"];
            this.isDeactivated = _data["isDeactivated"];
            if (Array.isArray(_data["documents"])) {
                this.documents = [] as any;
                for (let item of _data["documents"])
                    this.documents!.push(RetailerDocument.fromJS(item));
            }
            if (Array.isArray(_data["invoices"])) {
                this.invoices = [] as any;
                for (let item of _data["invoices"])
                    this.invoices!.push(Invoice.fromJS(item));
            }
            if (Array.isArray(_data["retailerNotifications"])) {
                this.retailerNotifications = [] as any;
                for (let item of _data["retailerNotifications"])
                    this.retailerNotifications!.push(RetailerNotification.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Retailer {
        data = typeof data === 'object' ? data : {};
        let result = new Retailer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["civility"] = this.civility;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["userId"] = this.userId;
        data["agentId"] = this.agentId;
        data["internalRetailerCode"] = this.internalRetailerCode;
        data["externalRetailerCode"] = this.externalRetailerCode;
        data["currentBalance"] = this.currentBalance;
        data["weeklySalesLimit"] = this.weeklySalesLimit;
        data["annualCA"] = this.annualCA;
        data["totalCommissions"] = this.totalCommissions;
        data["totalUnpaid"] = this.totalUnpaid;
        data["contractNumber"] = this.contractNumber;
        data["companyIdentifier"] = this.companyIdentifier;
        data["activity"] = this.activity;
        data["geographicSector"] = this.geographicSector;
        data["adressLatitude"] = this.adressLatitude;
        data["adressLongitude"] = this.adressLongitude;
        data["isNotified"] = this.isNotified;
        data["tradeRegister"] = this.tradeRegister;
        data["professionalTax"] = this.professionalTax;
        data["gpsCoordinates"] = this.gpsCoordinates;
        data["commercialZone"] = this.commercialZone;
        data["geoCodeHCP"] = this.geoCodeHCP;
        data["municipality"] = this.municipality;
        data["administrativeRegion"] = this.administrativeRegion;
        data["sglnCommercialName"] = this.sglnCommercialName;
        data["sglnCommercialPhone"] = this.sglnCommercialPhone;
        data["sglnCommercialMail"] = this.sglnCommercialMail;
        data["taxIdentification"] = this.taxIdentification;
        data["sisalCommercialName"] = this.sisalCommercialName;
        data["sisalCommercialMail"] = this.sisalCommercialMail;
        data["sisalCommercialPhone"] = this.sisalCommercialPhone;
        data["weeksNumber"] = this.weeksNumber;
        data["classification"] = this.classification;
        data["loyalityPoints"] = this.loyalityPoints;
        data["isDeactivated"] = this.isDeactivated;
        if (Array.isArray(this.documents)) {
            data["documents"] = [];
            for (let item of this.documents)
                data["documents"].push(item.toJSON());
        }
        if (Array.isArray(this.invoices)) {
            data["invoices"] = [];
            for (let item of this.invoices)
                data["invoices"].push(item.toJSON());
        }
        if (Array.isArray(this.retailerNotifications)) {
            data["retailerNotifications"] = [];
            for (let item of this.retailerNotifications)
                data["retailerNotifications"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IRetailer extends IContactBasedEntity {
    civility?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    userId?: string | undefined;
    agentId?: string | undefined;
    internalRetailerCode?: string | undefined;
    externalRetailerCode?: string | undefined;
    currentBalance?: number;
    weeklySalesLimit?: number;
    annualCA?: number;
    totalCommissions?: number;
    totalUnpaid?: number;
    contractNumber?: string | undefined;
    companyIdentifier?: string | undefined;
    activity?: string | undefined;
    geographicSector?: string | undefined;
    adressLatitude?: number;
    adressLongitude?: number;
    isNotified?: boolean;
    tradeRegister?: string | undefined;
    professionalTax?: string | undefined;
    gpsCoordinates?: string | undefined;
    commercialZone?: string | undefined;
    geoCodeHCP?: string | undefined;
    municipality?: string | undefined;
    administrativeRegion?: string | undefined;
    sglnCommercialName?: string | undefined;
    sglnCommercialPhone?: string | undefined;
    sglnCommercialMail?: string | undefined;
    taxIdentification?: string | undefined;
    sisalCommercialName?: string | undefined;
    sisalCommercialMail?: string | undefined;
    sisalCommercialPhone?: string | undefined;
    weeksNumber?: number;
    classification?: string | undefined;
    loyalityPoints?: number;
    isDeactivated?: boolean;
    documents?: RetailerDocument[] | undefined;
    invoices?: Invoice[] | undefined;
    retailerNotifications?: RetailerNotification[] | undefined;
}

export class RetailerDocument extends AbstractDocument implements IRetailerDocument {
    retailer?: Retailer | undefined;
    retailerId?: string;
    title?: string | undefined;

    constructor(data?: IRetailerDocument) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.retailer = _data["retailer"] ? Retailer.fromJS(_data["retailer"]) : <any>undefined;
            this.retailerId = _data["retailerId"];
            this.title = _data["title"];
        }
    }

    static fromJS(data: any): RetailerDocument {
        data = typeof data === 'object' ? data : {};
        let result = new RetailerDocument();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["retailer"] = this.retailer ? this.retailer.toJSON() : <any>undefined;
        data["retailerId"] = this.retailerId;
        data["title"] = this.title;
        super.toJSON(data);
        return data; 
    }
}

export interface IRetailerDocument extends IAbstractDocument {
    retailer?: Retailer | undefined;
    retailerId?: string;
    title?: string | undefined;
}

export class Invoice extends BaseEntityOfGuid implements IInvoice {
    reference?: string | undefined;
    status?: InvoiceStatusType;
    date?: Date;
    amount?: number;
    retailer?: Retailer | undefined;
    retailerId?: string;

    constructor(data?: IInvoice) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.reference = _data["reference"];
            this.status = _data["status"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.amount = _data["amount"];
            this.retailer = _data["retailer"] ? Retailer.fromJS(_data["retailer"]) : <any>undefined;
            this.retailerId = _data["retailerId"];
        }
    }

    static fromJS(data: any): Invoice {
        data = typeof data === 'object' ? data : {};
        let result = new Invoice();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reference"] = this.reference;
        data["status"] = this.status;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["amount"] = this.amount;
        data["retailer"] = this.retailer ? this.retailer.toJSON() : <any>undefined;
        data["retailerId"] = this.retailerId;
        super.toJSON(data);
        return data; 
    }
}

export interface IInvoice extends IBaseEntityOfGuid {
    reference?: string | undefined;
    status?: InvoiceStatusType;
    date?: Date;
    amount?: number;
    retailer?: Retailer | undefined;
    retailerId?: string;
}

export enum InvoiceStatusType {
    Paid = "Paid",
    Unpaid = "Unpaid",
}

export class Unit implements IUnit {

    constructor(data?: IUnit) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): Unit {
        data = typeof data === 'object' ? data : {};
        let result = new Unit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export interface IUnit {
}

export class PagedResultOfRequest extends PagedResultBase implements IPagedResultOfRequest {
    results?: Request[] | undefined;

    constructor(data?: IPagedResultOfRequest) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(Request.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultOfRequest {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IPagedResultOfRequest extends IPagedResultBase {
    results?: Request[] | undefined;
}

export class Request extends BaseEntityOfGuid implements IRequest {
    reference?: string | undefined;
    description?: string | undefined;
    requestObject?: string | undefined;
    requestCategoryId?: string;
    requestCategory?: RequestCategory | undefined;
    requestNature?: RequestNatureType;
    processingDirection?: ProcessingDirectionType | undefined;
    lastStatus?: RequestStatusType;
    requestAssignedTo?: RequestAffectationType;
    closingRetailerMessage?: string | undefined;
    closingDescriptionMessage?: string | undefined;
    retailer?: Retailer | undefined;
    retailerId?: string;
    documents?: RequestDocument[] | undefined;
    comments?: RequestComment[] | undefined;
    statuses?: RequestStatus[] | undefined;

    constructor(data?: IRequest) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.reference = _data["reference"];
            this.description = _data["description"];
            this.requestObject = _data["requestObject"];
            this.requestCategoryId = _data["requestCategoryId"];
            this.requestCategory = _data["requestCategory"] ? RequestCategory.fromJS(_data["requestCategory"]) : <any>undefined;
            this.requestNature = _data["requestNature"];
            this.processingDirection = _data["processingDirection"];
            this.lastStatus = _data["lastStatus"];
            this.requestAssignedTo = _data["requestAssignedTo"];
            this.closingRetailerMessage = _data["closingRetailerMessage"];
            this.closingDescriptionMessage = _data["closingDescriptionMessage"];
            this.retailer = _data["retailer"] ? Retailer.fromJS(_data["retailer"]) : <any>undefined;
            this.retailerId = _data["retailerId"];
            if (Array.isArray(_data["documents"])) {
                this.documents = [] as any;
                for (let item of _data["documents"])
                    this.documents!.push(RequestDocument.fromJS(item));
            }
            if (Array.isArray(_data["comments"])) {
                this.comments = [] as any;
                for (let item of _data["comments"])
                    this.comments!.push(RequestComment.fromJS(item));
            }
            if (Array.isArray(_data["statuses"])) {
                this.statuses = [] as any;
                for (let item of _data["statuses"])
                    this.statuses!.push(RequestStatus.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Request {
        data = typeof data === 'object' ? data : {};
        let result = new Request();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reference"] = this.reference;
        data["description"] = this.description;
        data["requestObject"] = this.requestObject;
        data["requestCategoryId"] = this.requestCategoryId;
        data["requestCategory"] = this.requestCategory ? this.requestCategory.toJSON() : <any>undefined;
        data["requestNature"] = this.requestNature;
        data["processingDirection"] = this.processingDirection;
        data["lastStatus"] = this.lastStatus;
        data["requestAssignedTo"] = this.requestAssignedTo;
        data["closingRetailerMessage"] = this.closingRetailerMessage;
        data["closingDescriptionMessage"] = this.closingDescriptionMessage;
        data["retailer"] = this.retailer ? this.retailer.toJSON() : <any>undefined;
        data["retailerId"] = this.retailerId;
        if (Array.isArray(this.documents)) {
            data["documents"] = [];
            for (let item of this.documents)
                data["documents"].push(item.toJSON());
        }
        if (Array.isArray(this.comments)) {
            data["comments"] = [];
            for (let item of this.comments)
                data["comments"].push(item.toJSON());
        }
        if (Array.isArray(this.statuses)) {
            data["statuses"] = [];
            for (let item of this.statuses)
                data["statuses"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IRequest extends IBaseEntityOfGuid {
    reference?: string | undefined;
    description?: string | undefined;
    requestObject?: string | undefined;
    requestCategoryId?: string;
    requestCategory?: RequestCategory | undefined;
    requestNature?: RequestNatureType;
    processingDirection?: ProcessingDirectionType | undefined;
    lastStatus?: RequestStatusType;
    requestAssignedTo?: RequestAffectationType;
    closingRetailerMessage?: string | undefined;
    closingDescriptionMessage?: string | undefined;
    retailer?: Retailer | undefined;
    retailerId?: string;
    documents?: RequestDocument[] | undefined;
    comments?: RequestComment[] | undefined;
    statuses?: RequestStatus[] | undefined;
}

export enum RequestStatusType {
    Submitted = "Submitted",
    InProgress = "InProgress",
    Closed = "Closed",
    Contested = "Contested",
    Cancelled = "Cancelled",
}

export enum RequestAffectationType {
    ExternalAgent = "ExternalAgent",
    InternalAgent = "InternalAgent",
    None = "None",
}

export class RequestDocument extends AbstractDocument implements IRequestDocument {
    request?: Request | undefined;
    requestId?: string;

    constructor(data?: IRequestDocument) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.request = _data["request"] ? Request.fromJS(_data["request"]) : <any>undefined;
            this.requestId = _data["requestId"];
        }
    }

    static fromJS(data: any): RequestDocument {
        data = typeof data === 'object' ? data : {};
        let result = new RequestDocument();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["request"] = this.request ? this.request.toJSON() : <any>undefined;
        data["requestId"] = this.requestId;
        super.toJSON(data);
        return data; 
    }
}

export interface IRequestDocument extends IAbstractDocument {
    request?: Request | undefined;
    requestId?: string;
}

export abstract class AbstractComment extends BaseEntityOfGuid implements IAbstractComment {
    body?: string | undefined;

    constructor(data?: IAbstractComment) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.body = _data["body"];
        }
    }

    static fromJS(data: any): AbstractComment {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'AbstractComment' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["body"] = this.body;
        super.toJSON(data);
        return data; 
    }
}

export interface IAbstractComment extends IBaseEntityOfGuid {
    body?: string | undefined;
}

export class RequestComment extends AbstractComment implements IRequestComment {
    request?: Request | undefined;
    requestId?: string;

    constructor(data?: IRequestComment) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.request = _data["request"] ? Request.fromJS(_data["request"]) : <any>undefined;
            this.requestId = _data["requestId"];
        }
    }

    static fromJS(data: any): RequestComment {
        data = typeof data === 'object' ? data : {};
        let result = new RequestComment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["request"] = this.request ? this.request.toJSON() : <any>undefined;
        data["requestId"] = this.requestId;
        super.toJSON(data);
        return data; 
    }
}

export interface IRequestComment extends IAbstractComment {
    request?: Request | undefined;
    requestId?: string;
}

export class RequestStatus extends BaseEntityOfGuid implements IRequestStatus {
    request?: Request | undefined;
    requestId?: string;
    statusType?: RequestStatusType;
    comment?: string | undefined;

    constructor(data?: IRequestStatus) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.request = _data["request"] ? Request.fromJS(_data["request"]) : <any>undefined;
            this.requestId = _data["requestId"];
            this.statusType = _data["statusType"];
            this.comment = _data["comment"];
        }
    }

    static fromJS(data: any): RequestStatus {
        data = typeof data === 'object' ? data : {};
        let result = new RequestStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["request"] = this.request ? this.request.toJSON() : <any>undefined;
        data["requestId"] = this.requestId;
        data["statusType"] = this.statusType;
        data["comment"] = this.comment;
        super.toJSON(data);
        return data; 
    }
}

export interface IRequestStatus extends IBaseEntityOfGuid {
    request?: Request | undefined;
    requestId?: string;
    statusType?: RequestStatusType;
    comment?: string | undefined;
}

export class RequestVm implements IRequestVm {
    requestNature?: RequestNatureType;
    requestCategoryId?: string;
    requestObjectId?: string;
    description?: string | undefined;
    documentFileData?: string | undefined;
    documentFileName?: string | undefined;
    imageFileData?: string | undefined;
    imageFileName?: string | undefined;
    audioFileData?: string | undefined;
    audioFileName?: string | undefined;

    constructor(data?: IRequestVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.requestNature = _data["requestNature"];
            this.requestCategoryId = _data["requestCategoryId"];
            this.requestObjectId = _data["requestObjectId"];
            this.description = _data["description"];
            this.documentFileData = _data["documentFileData"];
            this.documentFileName = _data["documentFileName"];
            this.imageFileData = _data["imageFileData"];
            this.imageFileName = _data["imageFileName"];
            this.audioFileData = _data["audioFileData"];
            this.audioFileName = _data["audioFileName"];
        }
    }

    static fromJS(data: any): RequestVm {
        data = typeof data === 'object' ? data : {};
        let result = new RequestVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["requestNature"] = this.requestNature;
        data["requestCategoryId"] = this.requestCategoryId;
        data["requestObjectId"] = this.requestObjectId;
        data["description"] = this.description;
        data["documentFileData"] = this.documentFileData;
        data["documentFileName"] = this.documentFileName;
        data["imageFileData"] = this.imageFileData;
        data["imageFileName"] = this.imageFileName;
        data["audioFileData"] = this.audioFileData;
        data["audioFileName"] = this.audioFileName;
        return data; 
    }
}

export interface IRequestVm {
    requestNature?: RequestNatureType;
    requestCategoryId?: string;
    requestObjectId?: string;
    description?: string | undefined;
    documentFileData?: string | undefined;
    documentFileName?: string | undefined;
    imageFileData?: string | undefined;
    imageFileName?: string | undefined;
    audioFileData?: string | undefined;
    audioFileName?: string | undefined;
}

export class RetailerDetailsDto implements IRetailerDetailsDto {
    id?: string;
    civility?: string | undefined;
    userid?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    phone?: string | undefined;
    email?: string | undefined;
    address?: string | undefined;
    internalRetailerCode?: string | undefined;
    externalRetailerCode?: string | undefined;
    activity?: string | undefined;
    agentEmail?: string | undefined;
    agentUserName?: string | undefined;
    agentFirstName?: string | undefined;
    agentLastName?: string | undefined;
    agentPhoneNumber?: string | undefined;
    weeklySalesLimit?: number;
    annualCA?: number;
    totalCommissions?: number;
    totalUnpaid?: number;
    contractNumber?: string | undefined;
    companyIdentifier?: string | undefined;
    geographicSector?: string | undefined;
    currentBalance?: number;
    adressLatitude?: number;
    adressLongitude?: number;
    sglnCommercialName?: string | undefined;
    sglnCommercialPhone?: string | undefined;
    sglnCommercialMail?: string | undefined;
    sisalCommercialName?: string | undefined;
    sisalCommercialMail?: string | undefined;

    constructor(data?: IRetailerDetailsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.civility = _data["civility"];
            this.userid = _data["userid"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.phone = _data["phone"];
            this.email = _data["email"];
            this.address = _data["address"];
            this.internalRetailerCode = _data["internalRetailerCode"];
            this.externalRetailerCode = _data["externalRetailerCode"];
            this.activity = _data["activity"];
            this.agentEmail = _data["agentEmail"];
            this.agentUserName = _data["agentUserName"];
            this.agentFirstName = _data["agentFirstName"];
            this.agentLastName = _data["agentLastName"];
            this.agentPhoneNumber = _data["agentPhoneNumber"];
            this.weeklySalesLimit = _data["weeklySalesLimit"];
            this.annualCA = _data["annualCA"];
            this.totalCommissions = _data["totalCommissions"];
            this.totalUnpaid = _data["totalUnpaid"];
            this.contractNumber = _data["contractNumber"];
            this.companyIdentifier = _data["companyIdentifier"];
            this.geographicSector = _data["geographicSector"];
            this.currentBalance = _data["currentBalance"];
            this.adressLatitude = _data["adressLatitude"];
            this.adressLongitude = _data["adressLongitude"];
            this.sglnCommercialName = _data["sglnCommercialName"];
            this.sglnCommercialPhone = _data["sglnCommercialPhone"];
            this.sglnCommercialMail = _data["sglnCommercialMail"];
            this.sisalCommercialName = _data["sisalCommercialName"];
            this.sisalCommercialMail = _data["sisalCommercialMail"];
        }
    }

    static fromJS(data: any): RetailerDetailsDto {
        data = typeof data === 'object' ? data : {};
        let result = new RetailerDetailsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["civility"] = this.civility;
        data["userid"] = this.userid;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["phone"] = this.phone;
        data["email"] = this.email;
        data["address"] = this.address;
        data["internalRetailerCode"] = this.internalRetailerCode;
        data["externalRetailerCode"] = this.externalRetailerCode;
        data["activity"] = this.activity;
        data["agentEmail"] = this.agentEmail;
        data["agentUserName"] = this.agentUserName;
        data["agentFirstName"] = this.agentFirstName;
        data["agentLastName"] = this.agentLastName;
        data["agentPhoneNumber"] = this.agentPhoneNumber;
        data["weeklySalesLimit"] = this.weeklySalesLimit;
        data["annualCA"] = this.annualCA;
        data["totalCommissions"] = this.totalCommissions;
        data["totalUnpaid"] = this.totalUnpaid;
        data["contractNumber"] = this.contractNumber;
        data["companyIdentifier"] = this.companyIdentifier;
        data["geographicSector"] = this.geographicSector;
        data["currentBalance"] = this.currentBalance;
        data["adressLatitude"] = this.adressLatitude;
        data["adressLongitude"] = this.adressLongitude;
        data["sglnCommercialName"] = this.sglnCommercialName;
        data["sglnCommercialPhone"] = this.sglnCommercialPhone;
        data["sglnCommercialMail"] = this.sglnCommercialMail;
        data["sisalCommercialName"] = this.sisalCommercialName;
        data["sisalCommercialMail"] = this.sisalCommercialMail;
        return data; 
    }
}

export interface IRetailerDetailsDto {
    id?: string;
    civility?: string | undefined;
    userid?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    phone?: string | undefined;
    email?: string | undefined;
    address?: string | undefined;
    internalRetailerCode?: string | undefined;
    externalRetailerCode?: string | undefined;
    activity?: string | undefined;
    agentEmail?: string | undefined;
    agentUserName?: string | undefined;
    agentFirstName?: string | undefined;
    agentLastName?: string | undefined;
    agentPhoneNumber?: string | undefined;
    weeklySalesLimit?: number;
    annualCA?: number;
    totalCommissions?: number;
    totalUnpaid?: number;
    contractNumber?: string | undefined;
    companyIdentifier?: string | undefined;
    geographicSector?: string | undefined;
    currentBalance?: number;
    adressLatitude?: number;
    adressLongitude?: number;
    sglnCommercialName?: string | undefined;
    sglnCommercialPhone?: string | undefined;
    sglnCommercialMail?: string | undefined;
    sisalCommercialName?: string | undefined;
    sisalCommercialMail?: string | undefined;
}

export class User implements IUser {
    id?: string | undefined;
    email?: string | undefined;
    userName?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    phoneNumber?: string | undefined;
    emailConfirmed?: boolean | undefined;
    phoneNumberConfirmed?: boolean | undefined;
    createdBy?: string | undefined;
    created?: Date;
    lastModifiedBy?: string | undefined;
    lastModified?: Date | undefined;
    isExternal?: boolean | undefined;
    isDeleted?: boolean | undefined;
    isDeactivated?: boolean;
    isValidated?: boolean;
    administration?: ProcessingDirectionType | undefined;
    roleName?: string | undefined;
    permissions?: string[] | undefined;

    constructor(data?: IUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.email = _data["email"];
            this.userName = _data["userName"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.phoneNumber = _data["phoneNumber"];
            this.emailConfirmed = _data["emailConfirmed"];
            this.phoneNumberConfirmed = _data["phoneNumberConfirmed"];
            this.createdBy = _data["createdBy"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.lastModifiedBy = _data["lastModifiedBy"];
            this.lastModified = _data["lastModified"] ? new Date(_data["lastModified"].toString()) : <any>undefined;
            this.isExternal = _data["isExternal"];
            this.isDeleted = _data["isDeleted"];
            this.isDeactivated = _data["isDeactivated"];
            this.isValidated = _data["isValidated"];
            this.administration = _data["administration"];
            this.roleName = _data["roleName"];
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(item);
            }
        }
    }

    static fromJS(data: any): User {
        data = typeof data === 'object' ? data : {};
        let result = new User();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["email"] = this.email;
        data["userName"] = this.userName;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["phoneNumber"] = this.phoneNumber;
        data["emailConfirmed"] = this.emailConfirmed;
        data["phoneNumberConfirmed"] = this.phoneNumberConfirmed;
        data["createdBy"] = this.createdBy;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["lastModifiedBy"] = this.lastModifiedBy;
        data["lastModified"] = this.lastModified ? this.lastModified.toISOString() : <any>undefined;
        data["isExternal"] = this.isExternal;
        data["isDeleted"] = this.isDeleted;
        data["isDeactivated"] = this.isDeactivated;
        data["isValidated"] = this.isValidated;
        data["administration"] = this.administration;
        data["roleName"] = this.roleName;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item);
        }
        return data; 
    }
}

export interface IUser {
    id?: string | undefined;
    email?: string | undefined;
    userName?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    phoneNumber?: string | undefined;
    emailConfirmed?: boolean | undefined;
    phoneNumberConfirmed?: boolean | undefined;
    createdBy?: string | undefined;
    created?: Date;
    lastModifiedBy?: string | undefined;
    lastModified?: Date | undefined;
    isExternal?: boolean | undefined;
    isDeleted?: boolean | undefined;
    isDeactivated?: boolean;
    isValidated?: boolean;
    administration?: ProcessingDirectionType | undefined;
    roleName?: string | undefined;
    permissions?: string[] | undefined;
}

export class TrainingModuleDTO implements ITrainingModuleDTO {
    id?: string;
    title?: string | undefined;
    countTrainings?: number;
    created?: Date;

    constructor(data?: ITrainingModuleDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.countTrainings = _data["countTrainings"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): TrainingModuleDTO {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingModuleDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["countTrainings"] = this.countTrainings;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        return data; 
    }
}

export interface ITrainingModuleDTO {
    id?: string;
    title?: string | undefined;
    countTrainings?: number;
    created?: Date;
}

export class TrainingModule extends BaseEntityOfGuid implements ITrainingModule {
    title?: string | undefined;
    trainings?: Training[] | undefined;

    constructor(data?: ITrainingModule) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.title = _data["title"];
            if (Array.isArray(_data["trainings"])) {
                this.trainings = [] as any;
                for (let item of _data["trainings"])
                    this.trainings!.push(Training.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TrainingModule {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingModule();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        if (Array.isArray(this.trainings)) {
            data["trainings"] = [];
            for (let item of this.trainings)
                data["trainings"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface ITrainingModule extends IBaseEntityOfGuid {
    title?: string | undefined;
    trainings?: Training[] | undefined;
}

export class Training extends BaseEntityOfGuid implements ITraining {
    module?: TrainingModule | undefined;
    moduleId?: string | undefined;
    title?: string | undefined;
    description?: string | undefined;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    type?: TrainingType;
    courseURI?: string | undefined;
    questions?: TrainingQuestion[] | undefined;
    documents?: TrainingDocument[] | undefined;
    retailerTrainings?: RetailerTraining[] | undefined;
    isPublished?: boolean;

    constructor(data?: ITraining) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.module = _data["module"] ? TrainingModule.fromJS(_data["module"]) : <any>undefined;
            this.moduleId = _data["moduleId"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.type = _data["type"];
            this.courseURI = _data["courseURI"];
            if (Array.isArray(_data["questions"])) {
                this.questions = [] as any;
                for (let item of _data["questions"])
                    this.questions!.push(TrainingQuestion.fromJS(item));
            }
            if (Array.isArray(_data["documents"])) {
                this.documents = [] as any;
                for (let item of _data["documents"])
                    this.documents!.push(TrainingDocument.fromJS(item));
            }
            if (Array.isArray(_data["retailerTrainings"])) {
                this.retailerTrainings = [] as any;
                for (let item of _data["retailerTrainings"])
                    this.retailerTrainings!.push(RetailerTraining.fromJS(item));
            }
            this.isPublished = _data["isPublished"];
        }
    }

    static fromJS(data: any): Training {
        data = typeof data === 'object' ? data : {};
        let result = new Training();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["module"] = this.module ? this.module.toJSON() : <any>undefined;
        data["moduleId"] = this.moduleId;
        data["title"] = this.title;
        data["description"] = this.description;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["type"] = this.type;
        data["courseURI"] = this.courseURI;
        if (Array.isArray(this.questions)) {
            data["questions"] = [];
            for (let item of this.questions)
                data["questions"].push(item.toJSON());
        }
        if (Array.isArray(this.documents)) {
            data["documents"] = [];
            for (let item of this.documents)
                data["documents"].push(item.toJSON());
        }
        if (Array.isArray(this.retailerTrainings)) {
            data["retailerTrainings"] = [];
            for (let item of this.retailerTrainings)
                data["retailerTrainings"].push(item.toJSON());
        }
        data["isPublished"] = this.isPublished;
        super.toJSON(data);
        return data; 
    }
}

export interface ITraining extends IBaseEntityOfGuid {
    module?: TrainingModule | undefined;
    moduleId?: string | undefined;
    title?: string | undefined;
    description?: string | undefined;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    type?: TrainingType;
    courseURI?: string | undefined;
    questions?: TrainingQuestion[] | undefined;
    documents?: TrainingDocument[] | undefined;
    retailerTrainings?: RetailerTraining[] | undefined;
    isPublished?: boolean;
}

export enum TrainingType {
    Interactive = "Interactive",
    Live = "Live",
    Video = "Video",
}

export class TrainingQuestion extends BaseEntityOfGuid implements ITrainingQuestion {
    label?: string | undefined;
    training?: Training | undefined;
    trainingId?: string;
    options?: TrainingQuestionOption[] | undefined;

    constructor(data?: ITrainingQuestion) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.label = _data["label"];
            this.training = _data["training"] ? Training.fromJS(_data["training"]) : <any>undefined;
            this.trainingId = _data["trainingId"];
            if (Array.isArray(_data["options"])) {
                this.options = [] as any;
                for (let item of _data["options"])
                    this.options!.push(TrainingQuestionOption.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TrainingQuestion {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingQuestion();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["label"] = this.label;
        data["training"] = this.training ? this.training.toJSON() : <any>undefined;
        data["trainingId"] = this.trainingId;
        if (Array.isArray(this.options)) {
            data["options"] = [];
            for (let item of this.options)
                data["options"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface ITrainingQuestion extends IBaseEntityOfGuid {
    label?: string | undefined;
    training?: Training | undefined;
    trainingId?: string;
    options?: TrainingQuestionOption[] | undefined;
}

export class TrainingQuestionOption extends BaseEntityOfGuid implements ITrainingQuestionOption {
    label?: string | undefined;
    isCorrect?: boolean;
    trainingQuestionId?: string;
    trainingQuestion?: TrainingQuestion | undefined;

    constructor(data?: ITrainingQuestionOption) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.label = _data["label"];
            this.isCorrect = _data["isCorrect"];
            this.trainingQuestionId = _data["trainingQuestionId"];
            this.trainingQuestion = _data["trainingQuestion"] ? TrainingQuestion.fromJS(_data["trainingQuestion"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TrainingQuestionOption {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingQuestionOption();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["label"] = this.label;
        data["isCorrect"] = this.isCorrect;
        data["trainingQuestionId"] = this.trainingQuestionId;
        data["trainingQuestion"] = this.trainingQuestion ? this.trainingQuestion.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

export interface ITrainingQuestionOption extends IBaseEntityOfGuid {
    label?: string | undefined;
    isCorrect?: boolean;
    trainingQuestionId?: string;
    trainingQuestion?: TrainingQuestion | undefined;
}

export class TrainingDocument extends AbstractDocument implements ITrainingDocument {
    training?: Training | undefined;
    trainingId?: string;
    title?: string | undefined;
    body?: string | undefined;

    constructor(data?: ITrainingDocument) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.training = _data["training"] ? Training.fromJS(_data["training"]) : <any>undefined;
            this.trainingId = _data["trainingId"];
            this.title = _data["title"];
            this.body = _data["body"];
        }
    }

    static fromJS(data: any): TrainingDocument {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingDocument();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["training"] = this.training ? this.training.toJSON() : <any>undefined;
        data["trainingId"] = this.trainingId;
        data["title"] = this.title;
        data["body"] = this.body;
        super.toJSON(data);
        return data; 
    }
}

export interface ITrainingDocument extends IAbstractDocument {
    training?: Training | undefined;
    trainingId?: string;
    title?: string | undefined;
    body?: string | undefined;
}

export class RetailerTraining extends BaseEntityOfGuid implements IRetailerTraining {
    retailer?: Retailer | undefined;
    retailerId?: string;
    training?: Training | undefined;
    trainingId?: string;
    lastStatus?: TrainingStatusType;
    score?: number | undefined;
    scoreRate?: number | undefined;
    statuses?: RetailerTrainingStatus[] | undefined;

    constructor(data?: IRetailerTraining) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.retailer = _data["retailer"] ? Retailer.fromJS(_data["retailer"]) : <any>undefined;
            this.retailerId = _data["retailerId"];
            this.training = _data["training"] ? Training.fromJS(_data["training"]) : <any>undefined;
            this.trainingId = _data["trainingId"];
            this.lastStatus = _data["lastStatus"];
            this.score = _data["score"];
            this.scoreRate = _data["scoreRate"];
            if (Array.isArray(_data["statuses"])) {
                this.statuses = [] as any;
                for (let item of _data["statuses"])
                    this.statuses!.push(RetailerTrainingStatus.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RetailerTraining {
        data = typeof data === 'object' ? data : {};
        let result = new RetailerTraining();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["retailer"] = this.retailer ? this.retailer.toJSON() : <any>undefined;
        data["retailerId"] = this.retailerId;
        data["training"] = this.training ? this.training.toJSON() : <any>undefined;
        data["trainingId"] = this.trainingId;
        data["lastStatus"] = this.lastStatus;
        data["score"] = this.score;
        data["scoreRate"] = this.scoreRate;
        if (Array.isArray(this.statuses)) {
            data["statuses"] = [];
            for (let item of this.statuses)
                data["statuses"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IRetailerTraining extends IBaseEntityOfGuid {
    retailer?: Retailer | undefined;
    retailerId?: string;
    training?: Training | undefined;
    trainingId?: string;
    lastStatus?: TrainingStatusType;
    score?: number | undefined;
    scoreRate?: number | undefined;
    statuses?: RetailerTrainingStatus[] | undefined;
}

export enum TrainingStatusType {
    InProgress = "InProgress",
    CourseFinished = "CourseFinished",
    TestCompleted = "TestCompleted",
}

export class RetailerTrainingStatus extends BaseEntityOfGuid implements IRetailerTrainingStatus {
    retailerTraining?: RetailerTraining | undefined;
    retailerTrainingId?: string;
    statusType?: TrainingStatusType;

    constructor(data?: IRetailerTrainingStatus) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.retailerTraining = _data["retailerTraining"] ? RetailerTraining.fromJS(_data["retailerTraining"]) : <any>undefined;
            this.retailerTrainingId = _data["retailerTrainingId"];
            this.statusType = _data["statusType"];
        }
    }

    static fromJS(data: any): RetailerTrainingStatus {
        data = typeof data === 'object' ? data : {};
        let result = new RetailerTrainingStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["retailerTraining"] = this.retailerTraining ? this.retailerTraining.toJSON() : <any>undefined;
        data["retailerTrainingId"] = this.retailerTrainingId;
        data["statusType"] = this.statusType;
        super.toJSON(data);
        return data; 
    }
}

export interface IRetailerTrainingStatus extends IBaseEntityOfGuid {
    retailerTraining?: RetailerTraining | undefined;
    retailerTrainingId?: string;
    statusType?: TrainingStatusType;
}

export class TrainingVm implements ITrainingVm {
    id?: string;
    title?: string | undefined;
    description?: string | undefined;
    courseURI?: string | undefined;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    type?: TrainingType;
    lastStatus?: TrainingStatusType | undefined;
    score?: number | undefined;
    scoreRate?: number | undefined;
    created?: Date;
    documentId?: string | undefined;
    documentType?: DocumentType | undefined;
    documentUri?: string | undefined;
    documentTitle?: string | undefined;
    documentMimeType?: string | undefined;

    constructor(data?: ITrainingVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.courseURI = _data["courseURI"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.type = _data["type"];
            this.lastStatus = _data["lastStatus"];
            this.score = _data["score"];
            this.scoreRate = _data["scoreRate"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.documentId = _data["documentId"];
            this.documentType = _data["documentType"];
            this.documentUri = _data["documentUri"];
            this.documentTitle = _data["documentTitle"];
            this.documentMimeType = _data["documentMimeType"];
        }
    }

    static fromJS(data: any): TrainingVm {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["description"] = this.description;
        data["courseURI"] = this.courseURI;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["type"] = this.type;
        data["lastStatus"] = this.lastStatus;
        data["score"] = this.score;
        data["scoreRate"] = this.scoreRate;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["documentId"] = this.documentId;
        data["documentType"] = this.documentType;
        data["documentUri"] = this.documentUri;
        data["documentTitle"] = this.documentTitle;
        data["documentMimeType"] = this.documentMimeType;
        return data; 
    }
}

export interface ITrainingVm {
    id?: string;
    title?: string | undefined;
    description?: string | undefined;
    courseURI?: string | undefined;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    type?: TrainingType;
    lastStatus?: TrainingStatusType | undefined;
    score?: number | undefined;
    scoreRate?: number | undefined;
    created?: Date;
    documentId?: string | undefined;
    documentType?: DocumentType | undefined;
    documentUri?: string | undefined;
    documentTitle?: string | undefined;
    documentMimeType?: string | undefined;
}

export class InteractiveTrainingDocumentVm implements IInteractiveTrainingDocumentVm {
    trainingTitle?: string | undefined;
    moduleName?: string | undefined;
    listTrainingCourseSlide?: InteractiveTrainingCourseSlideVm[] | undefined;

    constructor(data?: IInteractiveTrainingDocumentVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.trainingTitle = _data["trainingTitle"];
            this.moduleName = _data["moduleName"];
            if (Array.isArray(_data["listTrainingCourseSlide"])) {
                this.listTrainingCourseSlide = [] as any;
                for (let item of _data["listTrainingCourseSlide"])
                    this.listTrainingCourseSlide!.push(InteractiveTrainingCourseSlideVm.fromJS(item));
            }
        }
    }

    static fromJS(data: any): InteractiveTrainingDocumentVm {
        data = typeof data === 'object' ? data : {};
        let result = new InteractiveTrainingDocumentVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["trainingTitle"] = this.trainingTitle;
        data["moduleName"] = this.moduleName;
        if (Array.isArray(this.listTrainingCourseSlide)) {
            data["listTrainingCourseSlide"] = [];
            for (let item of this.listTrainingCourseSlide)
                data["listTrainingCourseSlide"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IInteractiveTrainingDocumentVm {
    trainingTitle?: string | undefined;
    moduleName?: string | undefined;
    listTrainingCourseSlide?: InteractiveTrainingCourseSlideVm[] | undefined;
}

export class InteractiveTrainingCourseSlideVm implements IInteractiveTrainingCourseSlideVm {
    title?: string | undefined;
    body?: string | undefined;
    id?: string;
    type?: DocumentType;

    constructor(data?: IInteractiveTrainingCourseSlideVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.body = _data["body"];
            this.id = _data["id"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): InteractiveTrainingCourseSlideVm {
        data = typeof data === 'object' ? data : {};
        let result = new InteractiveTrainingCourseSlideVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["body"] = this.body;
        data["id"] = this.id;
        data["type"] = this.type;
        return data; 
    }
}

export interface IInteractiveTrainingCourseSlideVm {
    title?: string | undefined;
    body?: string | undefined;
    id?: string;
    type?: DocumentType;
}

export class CompleteTrainingVm implements ICompleteTrainingVm {
    id?: string | undefined;
    type?: DocumentType | undefined;
    documentUri?: string | undefined;
    documentTitle?: string | undefined;
    documentMimeType?: string | undefined;
    scoreRate?: number;

    constructor(data?: ICompleteTrainingVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.type = _data["type"];
            this.documentUri = _data["documentUri"];
            this.documentTitle = _data["documentTitle"];
            this.documentMimeType = _data["documentMimeType"];
            this.scoreRate = _data["scoreRate"];
        }
    }

    static fromJS(data: any): CompleteTrainingVm {
        data = typeof data === 'object' ? data : {};
        let result = new CompleteTrainingVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["type"] = this.type;
        data["documentUri"] = this.documentUri;
        data["documentTitle"] = this.documentTitle;
        data["documentMimeType"] = this.documentMimeType;
        data["scoreRate"] = this.scoreRate;
        return data; 
    }
}

export interface ICompleteTrainingVm {
    id?: string | undefined;
    type?: DocumentType | undefined;
    documentUri?: string | undefined;
    documentTitle?: string | undefined;
    documentMimeType?: string | undefined;
    scoreRate?: number;
}

export class PagedResultOfUser extends PagedResultBase implements IPagedResultOfUser {
    results?: User[] | undefined;

    constructor(data?: IPagedResultOfUser) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(User.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultOfUser {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IPagedResultOfUser extends IPagedResultBase {
    results?: User[] | undefined;
}

export class ChangePasswordData implements IChangePasswordData {
    currentPassword!: string;
    newPassword!: string;

    constructor(data?: IChangePasswordData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currentPassword = _data["currentPassword"];
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): ChangePasswordData {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentPassword"] = this.currentPassword;
        data["newPassword"] = this.newPassword;
        return data; 
    }
}

export interface IChangePasswordData {
    currentPassword: string;
    newPassword: string;
}

export class UserUpdateDto implements IUserUpdateDto {
    id?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    phoneNumber?: string | undefined;
    userName?: string | undefined;
    roleName?: string | undefined;
    administration?: ProcessingDirectionType | undefined;

    constructor(data?: IUserUpdateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.phoneNumber = _data["phoneNumber"];
            this.userName = _data["userName"];
            this.roleName = _data["roleName"];
            this.administration = _data["administration"];
        }
    }

    static fromJS(data: any): UserUpdateDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserUpdateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["phoneNumber"] = this.phoneNumber;
        data["userName"] = this.userName;
        data["roleName"] = this.roleName;
        data["administration"] = this.administration;
        return data; 
    }
}

export interface IUserUpdateDto {
    id?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    phoneNumber?: string | undefined;
    userName?: string | undefined;
    roleName?: string | undefined;
    administration?: ProcessingDirectionType | undefined;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new SwaggerException(message, status, response, headers, null);
}