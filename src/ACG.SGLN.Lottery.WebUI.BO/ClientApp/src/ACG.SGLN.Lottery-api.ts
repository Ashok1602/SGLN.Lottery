/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.3.0.0 (NJsonSchema v10.1.11.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import axios, { AxiosInstance, AxiosRequestConfig, AxiosResponse } from 'axios';

export interface IAnnouncementsClient {
    /**
     * Create new request
     * @param title (optional) 
     * @param body (optional) 
     * @param coverImage (optional) 
     * @return Created request object
     */
    create(title: string | null | undefined, body: string | null | undefined, coverImage: FileParameter | null | undefined): Promise<Request>;
    /**
     * Get Announcements list
     * @param page (optional) 
     * @param size (optional) 
     * @param minCreationDate (optional) 
     * @param maxCreationDate (optional) 
     * @param title (optional) 
     * @param isPublished (optional) 
     */
    get(page: number | null | undefined, size: number | null | undefined, minCreationDate: Date | null | undefined, maxCreationDate: Date | null | undefined, title: string | null | undefined, isPublished: boolean | null | undefined): Promise<PagedResultOfAnnouncement>;
    /**
     * Get Announcement by id
     */
    getById(id: string): Promise<Announcement>;
    /**
     * Delete Announcement by id
     */
    delete(id: string): Promise<Unit>;
    /**
     * Publish Announcement
     */
    publish(id: string): Promise<Unit>;
    /**
     * UnPublish Announcement
     */
    unpublish(id: string): Promise<Unit>;
}

export class AnnouncementsClient implements IAnnouncementsClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * Create new request
     * @param title (optional) 
     * @param body (optional) 
     * @param coverImage (optional) 
     * @return Created request object
     */
    create(title: string | null | undefined, body: string | null | undefined, coverImage: FileParameter | null | undefined): Promise<Request> {
        let url_ = this.baseUrl + "/api/announcements";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (title !== null && title !== undefined)
            content_.append("Title", title.toString());
        if (body !== null && body !== undefined)
            content_.append("Body", body.toString());
        if (coverImage !== null && coverImage !== undefined)
            content_.append("CoverImage", coverImage.data, coverImage.fileName ? coverImage.fileName : "CoverImage");

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<Request> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Request.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Request>(<any>null);
    }

    /**
     * Get Announcements list
     * @param page (optional) 
     * @param size (optional) 
     * @param minCreationDate (optional) 
     * @param maxCreationDate (optional) 
     * @param title (optional) 
     * @param isPublished (optional) 
     */
    get(page: number | null | undefined, size: number | null | undefined, minCreationDate: Date | null | undefined, maxCreationDate: Date | null | undefined, title: string | null | undefined, isPublished: boolean | null | undefined): Promise<PagedResultOfAnnouncement> {
        let url_ = this.baseUrl + "/api/announcements?";
        if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&"; 
        if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&"; 
        if (minCreationDate !== undefined)
            url_ += "MinCreationDate=" + encodeURIComponent(minCreationDate ? "" + minCreationDate.toJSON() : "") + "&"; 
        if (maxCreationDate !== undefined)
            url_ += "MaxCreationDate=" + encodeURIComponent(maxCreationDate ? "" + maxCreationDate.toJSON() : "") + "&"; 
        if (title !== undefined)
            url_ += "Title=" + encodeURIComponent("" + title) + "&"; 
        if (isPublished !== undefined)
            url_ += "IsPublished=" + encodeURIComponent("" + isPublished) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<PagedResultOfAnnouncement> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultOfAnnouncement.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultOfAnnouncement>(<any>null);
    }

    /**
     * Get Announcement by id
     */
    getById(id: string): Promise<Announcement> {
        let url_ = this.baseUrl + "/api/announcements/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: AxiosResponse): Promise<Announcement> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Announcement.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Announcement>(<any>null);
    }

    /**
     * Delete Announcement by id
     */
    delete(id: string): Promise<Unit> {
        let url_ = this.baseUrl + "/api/announcements/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<Unit> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Unit.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Unit>(<any>null);
    }

    /**
     * Publish Announcement
     */
    publish(id: string): Promise<Unit> {
        let url_ = this.baseUrl + "/api/announcements/{id}/publish";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processPublish(_response);
        });
    }

    protected processPublish(response: AxiosResponse): Promise<Unit> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Unit.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Unit>(<any>null);
    }

    /**
     * UnPublish Announcement
     */
    unpublish(id: string): Promise<Unit> {
        let url_ = this.baseUrl + "/api/announcements/{id}/unpublish";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processUnpublish(_response);
        });
    }

    protected processUnpublish(response: AxiosResponse): Promise<Unit> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Unit.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Unit>(<any>null);
    }
}

export interface IAuthClient {
    /**
     * Sign In Command
     */
    signIn(userSignInData: UserSignInDto): Promise<AuthenticationResult>;
    /**
     * Logout Command
     */
    logOut(deviceToken: string): Promise<void>;
}

export class AuthClient implements IAuthClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * Sign In Command
     */
    signIn(userSignInData: UserSignInDto): Promise<AuthenticationResult> {
        let url_ = this.baseUrl + "/api/auth/signin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(userSignInData);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processSignIn(_response);
        });
    }

    protected processSignIn(response: AxiosResponse): Promise<AuthenticationResult> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = AuthenticationResult.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<AuthenticationResult>(<any>null);
    }

    /**
     * Logout Command
     */
    logOut(deviceToken: string): Promise<void> {
        let url_ = this.baseUrl + "/api/auth/logout";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(deviceToken);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json", 
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processLogOut(_response);
        });
    }

    protected processLogOut(response: AxiosResponse): Promise<void> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            return Promise.resolve<void>(<any>null);
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<void>(<any>null);
    }
}

export interface ICitiesClient {
    /**
     * List all cities
     */
    get(): Promise<string[]>;
    create(entity: City): Promise<City>;
    /**
     * List all cities
     */
    getAll(): Promise<IdValueDtoOfInteger[]>;
    getById(id: number): Promise<City>;
    update(id: number, entity: City): Promise<Unit>;
    delete(id: number): Promise<Unit>;
}

export class CitiesClient implements ICitiesClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * List all cities
     */
    get(): Promise<string[]> {
        let url_ = this.baseUrl + "/api/cities";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<string[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string[]>(<any>null);
    }

    create(entity: City): Promise<City> {
        let url_ = this.baseUrl + "/api/cities";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<City> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = City.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<City>(<any>null);
    }

    /**
     * List all cities
     */
    getAll(): Promise<IdValueDtoOfInteger[]> {
        let url_ = this.baseUrl + "/api/cities/all";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGetAll(_response);
        });
    }

    protected processGetAll(response: AxiosResponse): Promise<IdValueDtoOfInteger[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(IdValueDtoOfInteger.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<IdValueDtoOfInteger[]>(<any>null);
    }

    getById(id: number): Promise<City> {
        let url_ = this.baseUrl + "/api/cities/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: AxiosResponse): Promise<City> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = City.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<City>(<any>null);
    }

    update(id: number, entity: City): Promise<Unit> {
        let url_ = this.baseUrl + "/api/cities/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<Unit> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Unit.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Unit>(<any>null);
    }

    delete(id: number): Promise<Unit> {
        let url_ = this.baseUrl + "/api/cities/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<Unit> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Unit.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Unit>(<any>null);
    }
}

export interface IDataIntegrationClient {
    /**
     * Add new Retailers and create a user account for them
     */
    createRetailers(data: RetailerDto[]): Promise<Retailer[]>;
    /**
     * Update Retailers
     */
    updateRetailers(data: RetailerUpdateDto[]): Promise<Retailer[]>;
    /**
     * Add a new Retailer and create a user account for him
     */
    createRetailer(data: RetailerDto): Promise<Retailer>;
    /**
     * Update a Retailer
     */
    updateRetailer(externalRetailerCode: string | null, data: RetailerUpdateDto): Promise<Retailer>;
}

export class DataIntegrationClient implements IDataIntegrationClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * Add new Retailers and create a user account for them
     */
    createRetailers(data: RetailerDto[]): Promise<Retailer[]> {
        let url_ = this.baseUrl + "/api/dataintegration/retailers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processCreateRetailers(_response);
        });
    }

    protected processCreateRetailers(response: AxiosResponse): Promise<Retailer[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Retailer.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Retailer[]>(<any>null);
    }

    /**
     * Update Retailers
     */
    updateRetailers(data: RetailerUpdateDto[]): Promise<Retailer[]> {
        let url_ = this.baseUrl + "/api/dataintegration/retailers";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processUpdateRetailers(_response);
        });
    }

    protected processUpdateRetailers(response: AxiosResponse): Promise<Retailer[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(Retailer.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Retailer[]>(<any>null);
    }

    /**
     * Add a new Retailer and create a user account for him
     */
    createRetailer(data: RetailerDto): Promise<Retailer> {
        let url_ = this.baseUrl + "/api/dataintegration/retailer";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processCreateRetailer(_response);
        });
    }

    protected processCreateRetailer(response: AxiosResponse): Promise<Retailer> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Retailer.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Retailer>(<any>null);
    }

    /**
     * Update a Retailer
     */
    updateRetailer(externalRetailerCode: string | null, data: RetailerUpdateDto): Promise<Retailer> {
        let url_ = this.baseUrl + "/api/dataintegration/retailer/{externalRetailerCode}";
        if (externalRetailerCode === undefined || externalRetailerCode === null)
            throw new Error("The parameter 'externalRetailerCode' must be defined.");
        url_ = url_.replace("{externalRetailerCode}", encodeURIComponent("" + externalRetailerCode)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(data);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processUpdateRetailer(_response);
        });
    }

    protected processUpdateRetailer(response: AxiosResponse): Promise<Retailer> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Retailer.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Retailer>(<any>null);
    }
}

export interface IDocumentsClient {
    /**
     * Upload a document
     * @param id (optional) 
     * @param type (optional) 
     * @param spec (optional) 
     * @param file (optional) 
     */
    upload(id: string | undefined, type: DocumentType | undefined, spec: DocumentSpec | undefined, file: FileParameter | null | undefined): Promise<DocumentDto>;
    /**
     * Download a document
     * @param isThumbnail (optional) 
     */
    download(type: DocumentType, id: string, isThumbnail: boolean | undefined): Promise<FileResponse>;
    /**
     * Download static documents by Value
     */
    downloadRequestNatureImage(type: RequestNatureType): Promise<FileResponse>;
    /**
     * Delete a document
     */
    delete(type: DocumentType, id: string): Promise<Unit>;
}

export class DocumentsClient implements IDocumentsClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * Upload a document
     * @param id (optional) 
     * @param type (optional) 
     * @param spec (optional) 
     * @param file (optional) 
     */
    upload(id: string | undefined, type: DocumentType | undefined, spec: DocumentSpec | undefined, file: FileParameter | null | undefined): Promise<DocumentDto> {
        let url_ = this.baseUrl + "/documents/upload?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&"; 
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "Type=" + encodeURIComponent("" + type) + "&"; 
        if (spec === null)
            throw new Error("The parameter 'spec' cannot be null.");
        else if (spec !== undefined)
            url_ += "Spec=" + encodeURIComponent("" + spec) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file !== null && file !== undefined)
            content_.append("File", file.data, file.fileName ? file.fileName : "File");

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processUpload(_response);
        });
    }

    protected processUpload(response: AxiosResponse): Promise<DocumentDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = DocumentDto.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<DocumentDto>(<any>null);
    }

    /**
     * Download a document
     * @param isThumbnail (optional) 
     */
    download(type: DocumentType, id: string, isThumbnail: boolean | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/documents/download/{type}/{id}?";
        if (type === undefined || type === null)
            throw new Error("The parameter 'type' must be defined.");
        url_ = url_.replace("{type}", encodeURIComponent("" + type)); 
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        if (isThumbnail === null)
            throw new Error("The parameter 'isThumbnail' cannot be null.");
        else if (isThumbnail !== undefined)
            url_ += "isThumbnail=" + encodeURIComponent("" + isThumbnail) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            responseType: "blob",
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processDownload(_response);
        });
    }

    protected processDownload(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Promise.resolve({ fileName: fileName, status: status, data: response.data as Blob, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    /**
     * Download static documents by Value
     */
    downloadRequestNatureImage(type: RequestNatureType): Promise<FileResponse> {
        let url_ = this.baseUrl + "/documents/download/requestnature/{type}";
        if (type === undefined || type === null)
            throw new Error("The parameter 'type' must be defined.");
        url_ = url_.replace("{type}", encodeURIComponent("" + type)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            responseType: "blob",
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processDownloadRequestNatureImage(_response);
        });
    }

    protected processDownloadRequestNatureImage(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Promise.resolve({ fileName: fileName, status: status, data: response.data as Blob, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    /**
     * Delete a document
     */
    delete(type: DocumentType, id: string): Promise<Unit> {
        let url_ = this.baseUrl + "/documents/{type}/{id}";
        if (type === undefined || type === null)
            throw new Error("The parameter 'type' must be defined.");
        url_ = url_.replace("{type}", encodeURIComponent("" + type)); 
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<Unit> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Unit.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Unit>(<any>null);
    }
}

export interface IExcellenceProgramsClient {
    /**
     * Get Incentives
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param minGoal (optional) 
     * @param maxGoal (optional) 
     * @param minAchievement (optional) 
     * @param maxAchievement (optional) 
     * @param retailerId (optional) 
     */
    getIncentives(startDate: Date | null | undefined, endDate: Date | null | undefined, minGoal: number | undefined, maxGoal: number | undefined, minAchievement: number | undefined, maxAchievement: number | undefined, retailerId: string | null | undefined): Promise<IncentiveDto[]>;
}

export class ExcellenceProgramsClient implements IExcellenceProgramsClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * Get Incentives
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param minGoal (optional) 
     * @param maxGoal (optional) 
     * @param minAchievement (optional) 
     * @param maxAchievement (optional) 
     * @param retailerId (optional) 
     */
    getIncentives(startDate: Date | null | undefined, endDate: Date | null | undefined, minGoal: number | undefined, maxGoal: number | undefined, minAchievement: number | undefined, maxAchievement: number | undefined, retailerId: string | null | undefined): Promise<IncentiveDto[]> {
        let url_ = this.baseUrl + "/api/excellenceprograms/incentives?";
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (minGoal === null)
            throw new Error("The parameter 'minGoal' cannot be null.");
        else if (minGoal !== undefined)
            url_ += "MinGoal=" + encodeURIComponent("" + minGoal) + "&"; 
        if (maxGoal === null)
            throw new Error("The parameter 'maxGoal' cannot be null.");
        else if (maxGoal !== undefined)
            url_ += "MaxGoal=" + encodeURIComponent("" + maxGoal) + "&"; 
        if (minAchievement === null)
            throw new Error("The parameter 'minAchievement' cannot be null.");
        else if (minAchievement !== undefined)
            url_ += "MinAchievement=" + encodeURIComponent("" + minAchievement) + "&"; 
        if (maxAchievement === null)
            throw new Error("The parameter 'maxAchievement' cannot be null.");
        else if (maxAchievement !== undefined)
            url_ += "MaxAchievement=" + encodeURIComponent("" + maxAchievement) + "&"; 
        if (retailerId !== undefined)
            url_ += "RetailerId=" + encodeURIComponent("" + retailerId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGetIncentives(_response);
        });
    }

    protected processGetIncentives(response: AxiosResponse): Promise<IncentiveDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(IncentiveDto.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<IncentiveDto[]>(<any>null);
    }
}

export interface INotificationsClient {
    /**
     * List all Notifications
     * @param page (optional) 
     * @param size (optional) 
     * @param type (optional) 
     * @param title (optional) 
     * @param body (optional) 
     * @param targetRetailerId (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     */
    get(page: number | null | undefined, size: number | null | undefined, type: NotificationType | null | undefined, title: string | null | undefined, body: string | null | undefined, targetRetailerId: string | null | undefined, startDate: Date | null | undefined, endDate: Date | null | undefined): Promise<PagedResultOfNotification>;
    /**
     * Creates a Notification
     */
    create(notificationDto: NotificationDto): Promise<Notification>;
    /**
     * Get Notification by id
     */
    getById(id: string): Promise<Notification>;
    /**
     * All Alerts
     */
    getStrippedNotifications(): Promise<IdValueDtoOfGuid[]>;
}

export class NotificationsClient implements INotificationsClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * List all Notifications
     * @param page (optional) 
     * @param size (optional) 
     * @param type (optional) 
     * @param title (optional) 
     * @param body (optional) 
     * @param targetRetailerId (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     */
    get(page: number | null | undefined, size: number | null | undefined, type: NotificationType | null | undefined, title: string | null | undefined, body: string | null | undefined, targetRetailerId: string | null | undefined, startDate: Date | null | undefined, endDate: Date | null | undefined): Promise<PagedResultOfNotification> {
        let url_ = this.baseUrl + "/api/notifications?";
        if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&"; 
        if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&"; 
        if (type !== undefined)
            url_ += "Type=" + encodeURIComponent("" + type) + "&"; 
        if (title !== undefined)
            url_ += "Title=" + encodeURIComponent("" + title) + "&"; 
        if (body !== undefined)
            url_ += "Body=" + encodeURIComponent("" + body) + "&"; 
        if (targetRetailerId !== undefined)
            url_ += "TargetRetailerId=" + encodeURIComponent("" + targetRetailerId) + "&"; 
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<PagedResultOfNotification> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultOfNotification.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultOfNotification>(<any>null);
    }

    /**
     * Creates a Notification
     */
    create(notificationDto: NotificationDto): Promise<Notification> {
        let url_ = this.baseUrl + "/api/notifications";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(notificationDto);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<Notification> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Notification.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Notification>(<any>null);
    }

    /**
     * Get Notification by id
     */
    getById(id: string): Promise<Notification> {
        let url_ = this.baseUrl + "/api/notifications/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: AxiosResponse): Promise<Notification> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Notification.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Notification>(<any>null);
    }

    /**
     * All Alerts
     */
    getStrippedNotifications(): Promise<IdValueDtoOfGuid[]> {
        let url_ = this.baseUrl + "/api/notifications/stripped";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGetStrippedNotifications(_response);
        });
    }

    protected processGetStrippedNotifications(response: AxiosResponse): Promise<IdValueDtoOfGuid[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(IdValueDtoOfGuid.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<IdValueDtoOfGuid[]>(<any>null);
    }
}

export interface IReportingClient {
    /**
     * Generate Trainings By Module report
     * @param moduleId (optional) 
     * @param training (optional) 
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @param documentFormat (optional) 
     */
    generateTrainingsByModuleReport(moduleId: string | null | undefined, training: string | null | undefined, fromDate: Date | null | undefined, toDate: Date | null | undefined, documentFormat: DocumentFormat | undefined): Promise<FileResponse>;
    /**
     * Generate Trainings By Retailer report
     * @param retailerId (optional) 
     * @param internalRetailerCode (optional) 
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @param documentFormat (optional) 
     */
    generateTrainingsByRetailerReport(retailerId: string | null | undefined, internalRetailerCode: string | null | undefined, fromDate: Date | null | undefined, toDate: Date | null | undefined, documentFormat: DocumentFormat | undefined): Promise<FileResponse>;
    /**
     * Generate Incentives report
     * @param type (optional) 
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @param documentFormat (optional) 
     */
    generateIncentivesReport(type: GameType | undefined, fromDate: Date | null | undefined, toDate: Date | null | undefined, documentFormat: DocumentFormat | undefined): Promise<FileResponse>;
    /**
     * Generate Ratio Requests Report
     * @param retailerId (optional) 
     * @param nature (optional) 
     * @param requestCategoryId (optional) 
     * @param requestObjectId (optional) 
     * @param status (optional) 
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @param documentFormat (optional) 
     */
    generateRatioRequestsReport(retailerId: string | null | undefined, nature: RequestNatureType | null | undefined, requestCategoryId: string | null | undefined, requestObjectId: string | null | undefined, status: RequestStatusType | undefined, fromDate: Date | null | undefined, toDate: Date | null | undefined, documentFormat: DocumentFormat | undefined): Promise<FileResponse>;
    /**
     * Generate Requests report
     * @param retailerId (optional) 
     * @param nature (optional) 
     * @param requestCategoryId (optional) 
     * @param requestObjectId (optional) 
     * @param status (optional) 
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @param documentFormat (optional) 
     */
    generateRequestsReport(retailerId: string | null | undefined, nature: RequestNatureType | null | undefined, requestCategoryId: string | null | undefined, requestObjectId: string | null | undefined, status: RequestStatusType | null | undefined, fromDate: Date | null | undefined, toDate: Date | null | undefined, documentFormat: DocumentFormat | undefined): Promise<FileResponse>;
    /**
     * Generate Processing Time Requests report
     * @param retailerId (optional) 
     * @param nature (optional) 
     * @param requestCategoryId (optional) 
     * @param requestObjectId (optional) 
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @param documentFormat (optional) 
     */
    generateProcessingTimeRequestsReport(retailerId: string | null | undefined, nature: RequestNatureType | null | undefined, requestCategoryId: string | null | undefined, requestObjectId: string | null | undefined, fromDate: Date | null | undefined, toDate: Date | null | undefined, documentFormat: DocumentFormat | undefined): Promise<FileResponse>;
    /**
     * Get Retailers Report
     * @param fromDate (optional) 
     * @param toDate (optional) 
     */
    getRetailerReport(fromDate: Date | null | undefined, toDate: Date | null | undefined): Promise<RetailersReportDto>;
}

export class ReportingClient implements IReportingClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * Generate Trainings By Module report
     * @param moduleId (optional) 
     * @param training (optional) 
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @param documentFormat (optional) 
     */
    generateTrainingsByModuleReport(moduleId: string | null | undefined, training: string | null | undefined, fromDate: Date | null | undefined, toDate: Date | null | undefined, documentFormat: DocumentFormat | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/reporting/trainingsbymodule?";
        if (moduleId !== undefined)
            url_ += "ModuleId=" + encodeURIComponent("" + moduleId) + "&"; 
        if (training !== undefined)
            url_ += "Training=" + encodeURIComponent("" + training) + "&"; 
        if (fromDate !== undefined)
            url_ += "fromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toJSON() : "") + "&"; 
        if (toDate !== undefined)
            url_ += "toDate=" + encodeURIComponent(toDate ? "" + toDate.toJSON() : "") + "&"; 
        if (documentFormat === null)
            throw new Error("The parameter 'documentFormat' cannot be null.");
        else if (documentFormat !== undefined)
            url_ += "documentFormat=" + encodeURIComponent("" + documentFormat) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            responseType: "blob",
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGenerateTrainingsByModuleReport(_response);
        });
    }

    protected processGenerateTrainingsByModuleReport(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Promise.resolve({ fileName: fileName, status: status, data: response.data as Blob, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    /**
     * Generate Trainings By Retailer report
     * @param retailerId (optional) 
     * @param internalRetailerCode (optional) 
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @param documentFormat (optional) 
     */
    generateTrainingsByRetailerReport(retailerId: string | null | undefined, internalRetailerCode: string | null | undefined, fromDate: Date | null | undefined, toDate: Date | null | undefined, documentFormat: DocumentFormat | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/reporting/trainingsbyretailer?";
        if (retailerId !== undefined)
            url_ += "RetailerId=" + encodeURIComponent("" + retailerId) + "&"; 
        if (internalRetailerCode !== undefined)
            url_ += "InternalRetailerCode=" + encodeURIComponent("" + internalRetailerCode) + "&"; 
        if (fromDate !== undefined)
            url_ += "fromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toJSON() : "") + "&"; 
        if (toDate !== undefined)
            url_ += "toDate=" + encodeURIComponent(toDate ? "" + toDate.toJSON() : "") + "&"; 
        if (documentFormat === null)
            throw new Error("The parameter 'documentFormat' cannot be null.");
        else if (documentFormat !== undefined)
            url_ += "documentFormat=" + encodeURIComponent("" + documentFormat) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            responseType: "blob",
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGenerateTrainingsByRetailerReport(_response);
        });
    }

    protected processGenerateTrainingsByRetailerReport(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Promise.resolve({ fileName: fileName, status: status, data: response.data as Blob, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    /**
     * Generate Incentives report
     * @param type (optional) 
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @param documentFormat (optional) 
     */
    generateIncentivesReport(type: GameType | undefined, fromDate: Date | null | undefined, toDate: Date | null | undefined, documentFormat: DocumentFormat | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/reporting/incentives?";
        if (type === null)
            throw new Error("The parameter 'type' cannot be null.");
        else if (type !== undefined)
            url_ += "Type=" + encodeURIComponent("" + type) + "&"; 
        if (fromDate !== undefined)
            url_ += "fromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toJSON() : "") + "&"; 
        if (toDate !== undefined)
            url_ += "toDate=" + encodeURIComponent(toDate ? "" + toDate.toJSON() : "") + "&"; 
        if (documentFormat === null)
            throw new Error("The parameter 'documentFormat' cannot be null.");
        else if (documentFormat !== undefined)
            url_ += "documentFormat=" + encodeURIComponent("" + documentFormat) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            responseType: "blob",
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGenerateIncentivesReport(_response);
        });
    }

    protected processGenerateIncentivesReport(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Promise.resolve({ fileName: fileName, status: status, data: response.data as Blob, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    /**
     * Generate Ratio Requests Report
     * @param retailerId (optional) 
     * @param nature (optional) 
     * @param requestCategoryId (optional) 
     * @param requestObjectId (optional) 
     * @param status (optional) 
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @param documentFormat (optional) 
     */
    generateRatioRequestsReport(retailerId: string | null | undefined, nature: RequestNatureType | null | undefined, requestCategoryId: string | null | undefined, requestObjectId: string | null | undefined, status: RequestStatusType | undefined, fromDate: Date | null | undefined, toDate: Date | null | undefined, documentFormat: DocumentFormat | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/reporting/ratiorequests?";
        if (retailerId !== undefined)
            url_ += "RetailerId=" + encodeURIComponent("" + retailerId) + "&"; 
        if (nature !== undefined)
            url_ += "Nature=" + encodeURIComponent("" + nature) + "&"; 
        if (requestCategoryId !== undefined)
            url_ += "RequestCategoryId=" + encodeURIComponent("" + requestCategoryId) + "&"; 
        if (requestObjectId !== undefined)
            url_ += "RequestObjectId=" + encodeURIComponent("" + requestObjectId) + "&"; 
        if (status === null)
            throw new Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            url_ += "Status=" + encodeURIComponent("" + status) + "&"; 
        if (fromDate !== undefined)
            url_ += "fromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toJSON() : "") + "&"; 
        if (toDate !== undefined)
            url_ += "toDate=" + encodeURIComponent(toDate ? "" + toDate.toJSON() : "") + "&"; 
        if (documentFormat === null)
            throw new Error("The parameter 'documentFormat' cannot be null.");
        else if (documentFormat !== undefined)
            url_ += "documentFormat=" + encodeURIComponent("" + documentFormat) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            responseType: "blob",
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGenerateRatioRequestsReport(_response);
        });
    }

    protected processGenerateRatioRequestsReport(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Promise.resolve({ fileName: fileName, status: status, data: response.data as Blob, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    /**
     * Generate Requests report
     * @param retailerId (optional) 
     * @param nature (optional) 
     * @param requestCategoryId (optional) 
     * @param requestObjectId (optional) 
     * @param status (optional) 
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @param documentFormat (optional) 
     */
    generateRequestsReport(retailerId: string | null | undefined, nature: RequestNatureType | null | undefined, requestCategoryId: string | null | undefined, requestObjectId: string | null | undefined, status: RequestStatusType | null | undefined, fromDate: Date | null | undefined, toDate: Date | null | undefined, documentFormat: DocumentFormat | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/reporting/requests?";
        if (retailerId !== undefined)
            url_ += "RetailerId=" + encodeURIComponent("" + retailerId) + "&"; 
        if (nature !== undefined)
            url_ += "Nature=" + encodeURIComponent("" + nature) + "&"; 
        if (requestCategoryId !== undefined)
            url_ += "RequestCategoryId=" + encodeURIComponent("" + requestCategoryId) + "&"; 
        if (requestObjectId !== undefined)
            url_ += "RequestObjectId=" + encodeURIComponent("" + requestObjectId) + "&"; 
        if (status !== undefined)
            url_ += "Status=" + encodeURIComponent("" + status) + "&"; 
        if (fromDate !== undefined)
            url_ += "fromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toJSON() : "") + "&"; 
        if (toDate !== undefined)
            url_ += "toDate=" + encodeURIComponent(toDate ? "" + toDate.toJSON() : "") + "&"; 
        if (documentFormat === null)
            throw new Error("The parameter 'documentFormat' cannot be null.");
        else if (documentFormat !== undefined)
            url_ += "documentFormat=" + encodeURIComponent("" + documentFormat) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            responseType: "blob",
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGenerateRequestsReport(_response);
        });
    }

    protected processGenerateRequestsReport(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Promise.resolve({ fileName: fileName, status: status, data: response.data as Blob, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    /**
     * Generate Processing Time Requests report
     * @param retailerId (optional) 
     * @param nature (optional) 
     * @param requestCategoryId (optional) 
     * @param requestObjectId (optional) 
     * @param fromDate (optional) 
     * @param toDate (optional) 
     * @param documentFormat (optional) 
     */
    generateProcessingTimeRequestsReport(retailerId: string | null | undefined, nature: RequestNatureType | null | undefined, requestCategoryId: string | null | undefined, requestObjectId: string | null | undefined, fromDate: Date | null | undefined, toDate: Date | null | undefined, documentFormat: DocumentFormat | undefined): Promise<FileResponse> {
        let url_ = this.baseUrl + "/reporting/processingtimerequests?";
        if (retailerId !== undefined)
            url_ += "RetailerId=" + encodeURIComponent("" + retailerId) + "&"; 
        if (nature !== undefined)
            url_ += "Nature=" + encodeURIComponent("" + nature) + "&"; 
        if (requestCategoryId !== undefined)
            url_ += "RequestCategoryId=" + encodeURIComponent("" + requestCategoryId) + "&"; 
        if (requestObjectId !== undefined)
            url_ += "RequestObjectId=" + encodeURIComponent("" + requestObjectId) + "&"; 
        if (fromDate !== undefined)
            url_ += "fromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toJSON() : "") + "&"; 
        if (toDate !== undefined)
            url_ += "toDate=" + encodeURIComponent(toDate ? "" + toDate.toJSON() : "") + "&"; 
        if (documentFormat === null)
            throw new Error("The parameter 'documentFormat' cannot be null.");
        else if (documentFormat !== undefined)
            url_ += "documentFormat=" + encodeURIComponent("" + documentFormat) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            responseType: "blob",
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/octet-stream"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGenerateProcessingTimeRequestsReport(_response);
        });
    }

    protected processGenerateProcessingTimeRequestsReport(response: AxiosResponse): Promise<FileResponse> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers["content-disposition"] : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return Promise.resolve({ fileName: fileName, status: status, data: response.data as Blob, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<FileResponse>(<any>null);
    }

    /**
     * Get Retailers Report
     * @param fromDate (optional) 
     * @param toDate (optional) 
     */
    getRetailerReport(fromDate: Date | null | undefined, toDate: Date | null | undefined): Promise<RetailersReportDto> {
        let url_ = this.baseUrl + "/reporting/retailers?";
        if (fromDate !== undefined)
            url_ += "fromDate=" + encodeURIComponent(fromDate ? "" + fromDate.toJSON() : "") + "&"; 
        if (toDate !== undefined)
            url_ += "toDate=" + encodeURIComponent(toDate ? "" + toDate.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGetRetailerReport(_response);
        });
    }

    protected processGetRetailerReport(response: AxiosResponse): Promise<RetailersReportDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = RetailersReportDto.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RetailersReportDto>(<any>null);
    }
}

export interface IRequestCategoriesClient {
    /**
     * Create a RequestCategory
     * @param requestNature (optional) 
     * @param title (optional) 
     * @param coverImage (optional) 
     */
    create(requestNature: RequestNatureType | undefined, title: string | null | undefined, coverImage: FileParameter | null | undefined): Promise<Unit>;
    /**
     * List all RequestCategorys
     * @param page (optional) 
     * @param size (optional) 
     * @param title (optional) 
     * @param requestNature (optional) 
     */
    get(page: number | null | undefined, size: number | null | undefined, title: string | null | undefined, requestNature: RequestNatureType | null | undefined): Promise<PagedResultOfRequestCategory>;
    /**
     * Update a RequestCategory
     * @param requestNature (optional) 
     * @param title (optional) 
     * @param coverImage (optional) 
     * @param id (optional) 
     */
    update(requestNature: RequestNatureType | undefined, title: string | null | undefined, coverImage: FileParameter | null | undefined, id: string | undefined): Promise<Unit>;
    /**
     * Delete a RequestCategory
     */
    delete(id: string): Promise<Unit>;
    /**
     * Activates a RequestCategory
     */
    activate(id: string): Promise<Unit>;
    /**
     * Deactivate a RequestCategory
     */
    deactivate(id: string): Promise<Unit>;
    /**
     * List all RequestObjects
     */
    getStripped(): Promise<IdValueDtoOfGuid[]>;
    /**
     * List all RequestObjects
     */
    getStrippedByNature(requestNature: RequestNatureType): Promise<IdValueDtoOfGuid[]>;
}

export class RequestCategoriesClient implements IRequestCategoriesClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * Create a RequestCategory
     * @param requestNature (optional) 
     * @param title (optional) 
     * @param coverImage (optional) 
     */
    create(requestNature: RequestNatureType | undefined, title: string | null | undefined, coverImage: FileParameter | null | undefined): Promise<Unit> {
        let url_ = this.baseUrl + "/api/requestcategories";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (requestNature === null || requestNature === undefined)
            throw new Error("The parameter 'requestNature' cannot be null.");
        else
            content_.append("RequestNature", requestNature.toString());
        if (title !== null && title !== undefined)
            content_.append("Title", title.toString());
        if (coverImage !== null && coverImage !== undefined)
            content_.append("CoverImage", coverImage.data, coverImage.fileName ? coverImage.fileName : "CoverImage");

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<Unit> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Unit.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Unit>(<any>null);
    }

    /**
     * List all RequestCategorys
     * @param page (optional) 
     * @param size (optional) 
     * @param title (optional) 
     * @param requestNature (optional) 
     */
    get(page: number | null | undefined, size: number | null | undefined, title: string | null | undefined, requestNature: RequestNatureType | null | undefined): Promise<PagedResultOfRequestCategory> {
        let url_ = this.baseUrl + "/api/requestcategories?";
        if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&"; 
        if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&"; 
        if (title !== undefined)
            url_ += "Title=" + encodeURIComponent("" + title) + "&"; 
        if (requestNature !== undefined)
            url_ += "RequestNature=" + encodeURIComponent("" + requestNature) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<PagedResultOfRequestCategory> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultOfRequestCategory.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultOfRequestCategory>(<any>null);
    }

    /**
     * Update a RequestCategory
     * @param requestNature (optional) 
     * @param title (optional) 
     * @param coverImage (optional) 
     * @param id (optional) 
     */
    update(requestNature: RequestNatureType | undefined, title: string | null | undefined, coverImage: FileParameter | null | undefined, id: string | undefined): Promise<Unit> {
        let url_ = this.baseUrl + "/api/requestcategories?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "id=" + encodeURIComponent("" + id) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (requestNature === null || requestNature === undefined)
            throw new Error("The parameter 'requestNature' cannot be null.");
        else
            content_.append("RequestNature", requestNature.toString());
        if (title !== null && title !== undefined)
            content_.append("Title", title.toString());
        if (coverImage !== null && coverImage !== undefined)
            content_.append("CoverImage", coverImage.data, coverImage.fileName ? coverImage.fileName : "CoverImage");

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<Unit> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Unit.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Unit>(<any>null);
    }

    /**
     * Delete a RequestCategory
     */
    delete(id: string): Promise<Unit> {
        let url_ = this.baseUrl + "/api/requestcategories/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<Unit> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Unit.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Unit>(<any>null);
    }

    /**
     * Activates a RequestCategory
     */
    activate(id: string): Promise<Unit> {
        let url_ = this.baseUrl + "/api/requestcategories/{id}/activate";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processActivate(_response);
        });
    }

    protected processActivate(response: AxiosResponse): Promise<Unit> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Unit.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Unit>(<any>null);
    }

    /**
     * Deactivate a RequestCategory
     */
    deactivate(id: string): Promise<Unit> {
        let url_ = this.baseUrl + "/api/requestcategories/{id}/deactivate";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processDeactivate(_response);
        });
    }

    protected processDeactivate(response: AxiosResponse): Promise<Unit> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Unit.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Unit>(<any>null);
    }

    /**
     * List all RequestObjects
     */
    getStripped(): Promise<IdValueDtoOfGuid[]> {
        let url_ = this.baseUrl + "/api/requestcategories/stripped";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGetStripped(_response);
        });
    }

    protected processGetStripped(response: AxiosResponse): Promise<IdValueDtoOfGuid[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(IdValueDtoOfGuid.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<IdValueDtoOfGuid[]>(<any>null);
    }

    /**
     * List all RequestObjects
     */
    getStrippedByNature(requestNature: RequestNatureType): Promise<IdValueDtoOfGuid[]> {
        let url_ = this.baseUrl + "/api/requestcategories/{requestNature}/stripped";
        if (requestNature === undefined || requestNature === null)
            throw new Error("The parameter 'requestNature' must be defined.");
        url_ = url_.replace("{requestNature}", encodeURIComponent("" + requestNature)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGetStrippedByNature(_response);
        });
    }

    protected processGetStrippedByNature(response: AxiosResponse): Promise<IdValueDtoOfGuid[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(IdValueDtoOfGuid.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<IdValueDtoOfGuid[]>(<any>null);
    }
}

export interface IRequestCommentsClient {
    /**
     * Create a RequestComment
     */
    create(entity: RequestCommentDto): Promise<RequestComment>;
    /**
     * Delete a RequestComment
     */
    delete(id: string): Promise<Unit>;
}

export class RequestCommentsClient implements IRequestCommentsClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * Create a RequestComment
     */
    create(entity: RequestCommentDto): Promise<RequestComment> {
        let url_ = this.baseUrl + "/api/requestcomments";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(entity);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<RequestComment> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = RequestComment.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RequestComment>(<any>null);
    }

    /**
     * Delete a RequestComment
     */
    delete(id: string): Promise<Unit> {
        let url_ = this.baseUrl + "/api/requestcomments/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<Unit> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Unit.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Unit>(<any>null);
    }
}

export interface IRequestObjectsClient {
    /**
     * Create a RequestObject
     * @param title (optional) 
     * @param isExternal (optional) 
     * @param requestCategoryId (optional) 
     * @param coverImage (optional) 
     * @param processingDirection (optional) 
     */
    create(title: string | null | undefined, isExternal: boolean | null | undefined, requestCategoryId: string | undefined, coverImage: FileParameter | null | undefined, processingDirection: ProcessingDirectionType | null | undefined): Promise<Unit>;
    /**
     * List all RequestObjects
     * @param page (optional) 
     * @param size (optional) 
     * @param title (optional) 
     * @param requestCategoryId (optional) 
     * @param requestNature (optional) 
     */
    get(page: number | null | undefined, size: number | null | undefined, title: string | null | undefined, requestCategoryId: string | null | undefined, requestNature: RequestNatureType | null | undefined): Promise<PagedResultOfRequestObject>;
    /**
     * List all RequestObjects
     */
    getStrippedByCategory(requestCategoryId: string): Promise<IdValueDtoOfGuid[]>;
    /**
     * Update a RequestObject
     * @param title (optional) 
     * @param isExternal (optional) 
     * @param requestCategoryId (optional) 
     * @param coverImage (optional) 
     * @param processingDirection (optional) 
     */
    update(id: string, title: string | null | undefined, isExternal: boolean | null | undefined, requestCategoryId: string | undefined, coverImage: FileParameter | null | undefined, processingDirection: ProcessingDirectionType | null | undefined): Promise<Unit>;
    /**
     * Delete a RequestObject
     */
    delete(id: string): Promise<Unit>;
    /**
     * Activates a RequestObject
     */
    activate(id: string): Promise<Unit>;
    /**
     * Deactivate a RequestObject
     */
    deactivate(id: string): Promise<Unit>;
}

export class RequestObjectsClient implements IRequestObjectsClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * Create a RequestObject
     * @param title (optional) 
     * @param isExternal (optional) 
     * @param requestCategoryId (optional) 
     * @param coverImage (optional) 
     * @param processingDirection (optional) 
     */
    create(title: string | null | undefined, isExternal: boolean | null | undefined, requestCategoryId: string | undefined, coverImage: FileParameter | null | undefined, processingDirection: ProcessingDirectionType | null | undefined): Promise<Unit> {
        let url_ = this.baseUrl + "/api/requestobjects";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (title !== null && title !== undefined)
            content_.append("Title", title.toString());
        if (isExternal !== null && isExternal !== undefined)
            content_.append("IsExternal", isExternal.toString());
        if (requestCategoryId === null || requestCategoryId === undefined)
            throw new Error("The parameter 'requestCategoryId' cannot be null.");
        else
            content_.append("RequestCategoryId", requestCategoryId.toString());
        if (coverImage !== null && coverImage !== undefined)
            content_.append("CoverImage", coverImage.data, coverImage.fileName ? coverImage.fileName : "CoverImage");
        if (processingDirection !== null && processingDirection !== undefined)
            content_.append("ProcessingDirection", processingDirection.toString());

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<Unit> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Unit.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Unit>(<any>null);
    }

    /**
     * List all RequestObjects
     * @param page (optional) 
     * @param size (optional) 
     * @param title (optional) 
     * @param requestCategoryId (optional) 
     * @param requestNature (optional) 
     */
    get(page: number | null | undefined, size: number | null | undefined, title: string | null | undefined, requestCategoryId: string | null | undefined, requestNature: RequestNatureType | null | undefined): Promise<PagedResultOfRequestObject> {
        let url_ = this.baseUrl + "/api/requestobjects?";
        if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&"; 
        if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&"; 
        if (title !== undefined)
            url_ += "Title=" + encodeURIComponent("" + title) + "&"; 
        if (requestCategoryId !== undefined)
            url_ += "RequestCategoryId=" + encodeURIComponent("" + requestCategoryId) + "&"; 
        if (requestNature !== undefined)
            url_ += "RequestNature=" + encodeURIComponent("" + requestNature) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<PagedResultOfRequestObject> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultOfRequestObject.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultOfRequestObject>(<any>null);
    }

    /**
     * List all RequestObjects
     */
    getStrippedByCategory(requestCategoryId: string): Promise<IdValueDtoOfGuid[]> {
        let url_ = this.baseUrl + "/api/requestobjects/{requestCategoryId}/stripped";
        if (requestCategoryId === undefined || requestCategoryId === null)
            throw new Error("The parameter 'requestCategoryId' must be defined.");
        url_ = url_.replace("{requestCategoryId}", encodeURIComponent("" + requestCategoryId)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGetStrippedByCategory(_response);
        });
    }

    protected processGetStrippedByCategory(response: AxiosResponse): Promise<IdValueDtoOfGuid[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(IdValueDtoOfGuid.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<IdValueDtoOfGuid[]>(<any>null);
    }

    /**
     * Update a RequestObject
     * @param title (optional) 
     * @param isExternal (optional) 
     * @param requestCategoryId (optional) 
     * @param coverImage (optional) 
     * @param processingDirection (optional) 
     */
    update(id: string, title: string | null | undefined, isExternal: boolean | null | undefined, requestCategoryId: string | undefined, coverImage: FileParameter | null | undefined, processingDirection: ProcessingDirectionType | null | undefined): Promise<Unit> {
        let url_ = this.baseUrl + "/api/requestobjects/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (title !== null && title !== undefined)
            content_.append("Title", title.toString());
        if (isExternal !== null && isExternal !== undefined)
            content_.append("IsExternal", isExternal.toString());
        if (requestCategoryId === null || requestCategoryId === undefined)
            throw new Error("The parameter 'requestCategoryId' cannot be null.");
        else
            content_.append("RequestCategoryId", requestCategoryId.toString());
        if (coverImage !== null && coverImage !== undefined)
            content_.append("CoverImage", coverImage.data, coverImage.fileName ? coverImage.fileName : "CoverImage");
        if (processingDirection !== null && processingDirection !== undefined)
            content_.append("ProcessingDirection", processingDirection.toString());

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processUpdate(_response);
        });
    }

    protected processUpdate(response: AxiosResponse): Promise<Unit> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Unit.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Unit>(<any>null);
    }

    /**
     * Delete a RequestObject
     */
    delete(id: string): Promise<Unit> {
        let url_ = this.baseUrl + "/api/requestobjects/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<Unit> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Unit.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Unit>(<any>null);
    }

    /**
     * Activates a RequestObject
     */
    activate(id: string): Promise<Unit> {
        let url_ = this.baseUrl + "/api/requestobjects/{id}/activate";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processActivate(_response);
        });
    }

    protected processActivate(response: AxiosResponse): Promise<Unit> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Unit.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Unit>(<any>null);
    }

    /**
     * Deactivate a RequestObject
     */
    deactivate(id: string): Promise<Unit> {
        let url_ = this.baseUrl + "/api/requestobjects/{id}/deactivate";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processDeactivate(_response);
        });
    }

    protected processDeactivate(response: AxiosResponse): Promise<Unit> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Unit.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Unit>(<any>null);
    }
}

export interface IRequestsClient {
    /**
     * Get Requests list
     * @param page (optional) 
     * @param size (optional) 
     * @param requestObject (optional) 
     * @param requestCategoryId (optional) 
     * @param requestNature (optional) 
     * @param processingDirection (optional) 
     * @param lastStatus (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param retailer (optional) 
     * @param requestAssignedTo (optional) 
     * @param firstName (optional) 
     * @param lastName (optional) 
     * @param phone (optional) 
     * @param isNotified (optional) 
     */
    get(page: number | null | undefined, size: number | null | undefined, requestObject: string | null | undefined, requestCategoryId: string | null | undefined, requestNature: RequestNatureType | null | undefined, processingDirection: ProcessingDirectionType | null | undefined, lastStatus: RequestStatusType | null | undefined, startDate: Date | null | undefined, endDate: Date | null | undefined, retailer: string | null | undefined, requestAssignedTo: (RequestAffectationType | undefined)[] | null | undefined, firstName: string | null | undefined, lastName: string | null | undefined, phone: string | null | undefined, isNotified: boolean | null | undefined): Promise<PagedResultOfRequest>;
    /**
     * Get Request by id
     */
    getById(id: string): Promise<Request>;
    /**
     * assing request
     * @param isExternal (optional) 
     * @param processingDirection (optional) 
     */
    assign(id: string, isExternal: boolean | undefined, processingDirection: ProcessingDirectionType | null | undefined): Promise<Unit>;
    /**
     * Test
     */
    testMail(emails: string[]): Promise<Unit>;
    /**
     * RequestComment by Id
     */
    getCommentsById(id: string): Promise<RequestComment[]>;
    /**
     * start request
     */
    start(id: string): Promise<Unit>;
    /**
     * close request
     */
    close(id: string, closingDetail: CloseRequestDto): Promise<Unit>;
}

export class RequestsClient implements IRequestsClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * Get Requests list
     * @param page (optional) 
     * @param size (optional) 
     * @param requestObject (optional) 
     * @param requestCategoryId (optional) 
     * @param requestNature (optional) 
     * @param processingDirection (optional) 
     * @param lastStatus (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param retailer (optional) 
     * @param requestAssignedTo (optional) 
     * @param firstName (optional) 
     * @param lastName (optional) 
     * @param phone (optional) 
     * @param isNotified (optional) 
     */
    get(page: number | null | undefined, size: number | null | undefined, requestObject: string | null | undefined, requestCategoryId: string | null | undefined, requestNature: RequestNatureType | null | undefined, processingDirection: ProcessingDirectionType | null | undefined, lastStatus: RequestStatusType | null | undefined, startDate: Date | null | undefined, endDate: Date | null | undefined, retailer: string | null | undefined, requestAssignedTo: (RequestAffectationType | undefined)[] | null | undefined, firstName: string | null | undefined, lastName: string | null | undefined, phone: string | null | undefined, isNotified: boolean | null | undefined): Promise<PagedResultOfRequest> {
        let url_ = this.baseUrl + "/api/requests?";
        if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&"; 
        if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&"; 
        if (requestObject !== undefined)
            url_ += "RequestObject=" + encodeURIComponent("" + requestObject) + "&"; 
        if (requestCategoryId !== undefined)
            url_ += "RequestCategoryId=" + encodeURIComponent("" + requestCategoryId) + "&"; 
        if (requestNature !== undefined)
            url_ += "RequestNature=" + encodeURIComponent("" + requestNature) + "&"; 
        if (processingDirection !== undefined)
            url_ += "ProcessingDirection=" + encodeURIComponent("" + processingDirection) + "&"; 
        if (lastStatus !== undefined)
            url_ += "LastStatus=" + encodeURIComponent("" + lastStatus) + "&"; 
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (retailer !== undefined)
            url_ += "Retailer=" + encodeURIComponent("" + retailer) + "&"; 
        if (requestAssignedTo !== undefined)
            requestAssignedTo && requestAssignedTo.forEach(item => { url_ += "RequestAssignedTo=" + encodeURIComponent("" + item) + "&"; });
        if (firstName !== undefined)
            url_ += "FirstName=" + encodeURIComponent("" + firstName) + "&"; 
        if (lastName !== undefined)
            url_ += "LastName=" + encodeURIComponent("" + lastName) + "&"; 
        if (phone !== undefined)
            url_ += "Phone=" + encodeURIComponent("" + phone) + "&"; 
        if (isNotified !== undefined)
            url_ += "IsNotified=" + encodeURIComponent("" + isNotified) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<PagedResultOfRequest> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultOfRequest.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultOfRequest>(<any>null);
    }

    /**
     * Get Request by id
     */
    getById(id: string): Promise<Request> {
        let url_ = this.baseUrl + "/api/requests/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: AxiosResponse): Promise<Request> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Request.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Request>(<any>null);
    }

    /**
     * assing request
     * @param isExternal (optional) 
     * @param processingDirection (optional) 
     */
    assign(id: string, isExternal: boolean | undefined, processingDirection: ProcessingDirectionType | null | undefined): Promise<Unit> {
        let url_ = this.baseUrl + "/api/requests/{id}/assign?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        if (isExternal === null)
            throw new Error("The parameter 'isExternal' cannot be null.");
        else if (isExternal !== undefined)
            url_ += "isExternal=" + encodeURIComponent("" + isExternal) + "&"; 
        if (processingDirection !== undefined)
            url_ += "processingDirection=" + encodeURIComponent("" + processingDirection) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processAssign(_response);
        });
    }

    protected processAssign(response: AxiosResponse): Promise<Unit> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Unit.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Unit>(<any>null);
    }

    /**
     * Test
     */
    testMail(emails: string[]): Promise<Unit> {
        let url_ = this.baseUrl + "/api/requests/mailtest";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(emails);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processTestMail(_response);
        });
    }

    protected processTestMail(response: AxiosResponse): Promise<Unit> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Unit.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Unit>(<any>null);
    }

    /**
     * RequestComment by Id
     */
    getCommentsById(id: string): Promise<RequestComment[]> {
        let url_ = this.baseUrl + "/api/requests/{Id}/comments";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{Id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGetCommentsById(_response);
        });
    }

    protected processGetCommentsById(response: AxiosResponse): Promise<RequestComment[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RequestComment.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RequestComment[]>(<any>null);
    }

    /**
     * start request
     */
    start(id: string): Promise<Unit> {
        let url_ = this.baseUrl + "/api/requests/{id}/start";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processStart(_response);
        });
    }

    protected processStart(response: AxiosResponse): Promise<Unit> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Unit.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Unit>(<any>null);
    }

    /**
     * close request
     */
    close(id: string, closingDetail: CloseRequestDto): Promise<Unit> {
        let url_ = this.baseUrl + "/api/requests/{id}/close";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(closingDetail);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processClose(_response);
        });
    }

    protected processClose(response: AxiosResponse): Promise<Unit> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Unit.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Unit>(<any>null);
    }
}

export interface IRetailersClient {
    /**
     * Get retailers list
     * @param page (optional) 
     * @param size (optional) 
     * @param firstName (optional) 
     * @param lastName (optional) 
     * @param phone (optional) 
     * @param isNotified (optional) 
     */
    get(page: number | null | undefined, size: number | null | undefined, firstName: string | null | undefined, lastName: string | null | undefined, phone: string | null | undefined, isNotified: boolean | null | undefined): Promise<PagedResultOfRetailer>;
    /**
     * Get Retailers From excel file
     */
    getFromFile(): Promise<Unit>;
    /**
     * Get Retailer by id
     */
    getById(id: string): Promise<GetRetailerDto>;
    /**
     * Get Retailer Agent
     */
    getAgent(id: string): Promise<User>;
    /**
     * Sets Retailer Agent
     */
    assignAgent(id: string, agentId: string): Promise<Unit>;
    /**
     * Sets Retailer Sales Representative
     */
    assignSalesRepresentative(id: string, salesRepresentativedto: SalesRepresentativeDto): Promise<Unit>;
    /**
     * Sets mass Retailer Sales Representative
     */
    massAssignSalesRepresentative(salesRepresentativedto: SalesRepresentativeDto): Promise<Unit>;
    /**
     * List Stripped Retailers
     * @param filter (optional) 
     */
    getStrippedRetailers(filter: string | null | undefined): Promise<IdValueDtoOfGuid[]>;
    /**
     * List Municipalities
     */
    getMunicipalities(): Promise<string[]>;
}

export class RetailersClient implements IRetailersClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * Get retailers list
     * @param page (optional) 
     * @param size (optional) 
     * @param firstName (optional) 
     * @param lastName (optional) 
     * @param phone (optional) 
     * @param isNotified (optional) 
     */
    get(page: number | null | undefined, size: number | null | undefined, firstName: string | null | undefined, lastName: string | null | undefined, phone: string | null | undefined, isNotified: boolean | null | undefined): Promise<PagedResultOfRetailer> {
        let url_ = this.baseUrl + "/api/retailers?";
        if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&"; 
        if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&"; 
        if (firstName !== undefined)
            url_ += "FirstName=" + encodeURIComponent("" + firstName) + "&"; 
        if (lastName !== undefined)
            url_ += "LastName=" + encodeURIComponent("" + lastName) + "&"; 
        if (phone !== undefined)
            url_ += "Phone=" + encodeURIComponent("" + phone) + "&"; 
        if (isNotified !== undefined)
            url_ += "IsNotified=" + encodeURIComponent("" + isNotified) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<PagedResultOfRetailer> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultOfRetailer.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultOfRetailer>(<any>null);
    }

    /**
     * Get Retailers From excel file
     */
    getFromFile(): Promise<Unit> {
        let url_ = this.baseUrl + "/api/retailers/fromfile";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGetFromFile(_response);
        });
    }

    protected processGetFromFile(response: AxiosResponse): Promise<Unit> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Unit.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Unit>(<any>null);
    }

    /**
     * Get Retailer by id
     */
    getById(id: string): Promise<GetRetailerDto> {
        let url_ = this.baseUrl + "/api/retailers/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: AxiosResponse): Promise<GetRetailerDto> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = GetRetailerDto.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<GetRetailerDto>(<any>null);
    }

    /**
     * Get Retailer Agent
     */
    getAgent(id: string): Promise<User> {
        let url_ = this.baseUrl + "/api/retailers/{id}/agent";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGetAgent(_response);
        });
    }

    protected processGetAgent(response: AxiosResponse): Promise<User> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = User.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<User>(<any>null);
    }

    /**
     * Sets Retailer Agent
     */
    assignAgent(id: string, agentId: string): Promise<Unit> {
        let url_ = this.baseUrl + "/api/retailers/{id}/agent";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(agentId);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processAssignAgent(_response);
        });
    }

    protected processAssignAgent(response: AxiosResponse): Promise<Unit> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Unit.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Unit>(<any>null);
    }

    /**
     * Sets Retailer Sales Representative
     */
    assignSalesRepresentative(id: string, salesRepresentativedto: SalesRepresentativeDto): Promise<Unit> {
        let url_ = this.baseUrl + "/api/retailers/{id}/salesrepresentative";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(salesRepresentativedto);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processAssignSalesRepresentative(_response);
        });
    }

    protected processAssignSalesRepresentative(response: AxiosResponse): Promise<Unit> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Unit.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Unit>(<any>null);
    }

    /**
     * Sets mass Retailer Sales Representative
     */
    massAssignSalesRepresentative(salesRepresentativedto: SalesRepresentativeDto): Promise<Unit> {
        let url_ = this.baseUrl + "/api/retailers/mass/salesrepresentative";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(salesRepresentativedto);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processMassAssignSalesRepresentative(_response);
        });
    }

    protected processMassAssignSalesRepresentative(response: AxiosResponse): Promise<Unit> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Unit.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Unit>(<any>null);
    }

    /**
     * List Stripped Retailers
     * @param filter (optional) 
     */
    getStrippedRetailers(filter: string | null | undefined): Promise<IdValueDtoOfGuid[]> {
        let url_ = this.baseUrl + "/api/retailers/stripped?";
        if (filter !== undefined)
            url_ += "filter=" + encodeURIComponent("" + filter) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGetStrippedRetailers(_response);
        });
    }

    protected processGetStrippedRetailers(response: AxiosResponse): Promise<IdValueDtoOfGuid[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(IdValueDtoOfGuid.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<IdValueDtoOfGuid[]>(<any>null);
    }

    /**
     * List Municipalities
     */
    getMunicipalities(): Promise<string[]> {
        let url_ = this.baseUrl + "/api/retailers/municipalities";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGetMunicipalities(_response);
        });
    }

    protected processGetMunicipalities(response: AxiosResponse): Promise<string[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(item);
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<string[]>(<any>null);
    }
}

export interface IRolesClient {
    /**
     * Get roles
     */
    get(): Promise<RoleDto[]>;
}

export class RolesClient implements IRolesClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * Get roles
     */
    get(): Promise<RoleDto[]> {
        let url_ = this.baseUrl + "/api/roles";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<RoleDto[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(RoleDto.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<RoleDto[]>(<any>null);
    }
}

export interface ISupportDocumentsClient {
    /**
     * Get ApplicationDocuments list
     * @param page (optional) 
     * @param size (optional) 
     * @param title (optional) 
     * @param type (optional) 
     * @param minCreationDate (optional) 
     * @param maxCreationDate (optional) 
     */
    get(page: number | null | undefined, size: number | null | undefined, title: string | null | undefined, type: DocumentType | null | undefined, minCreationDate: Date | null | undefined, maxCreationDate: Date | null | undefined): Promise<PagedResultOfApplicationDocument>;
}

export class SupportDocumentsClient implements ISupportDocumentsClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * Get ApplicationDocuments list
     * @param page (optional) 
     * @param size (optional) 
     * @param title (optional) 
     * @param type (optional) 
     * @param minCreationDate (optional) 
     * @param maxCreationDate (optional) 
     */
    get(page: number | null | undefined, size: number | null | undefined, title: string | null | undefined, type: DocumentType | null | undefined, minCreationDate: Date | null | undefined, maxCreationDate: Date | null | undefined): Promise<PagedResultOfApplicationDocument> {
        let url_ = this.baseUrl + "/api/supportdocuments?";
        if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&"; 
        if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&"; 
        if (title !== undefined)
            url_ += "Title=" + encodeURIComponent("" + title) + "&"; 
        if (type !== undefined)
            url_ += "Type=" + encodeURIComponent("" + type) + "&"; 
        if (minCreationDate !== undefined)
            url_ += "MinCreationDate=" + encodeURIComponent(minCreationDate ? "" + minCreationDate.toJSON() : "") + "&"; 
        if (maxCreationDate !== undefined)
            url_ += "MaxCreationDate=" + encodeURIComponent(maxCreationDate ? "" + maxCreationDate.toJSON() : "") + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<PagedResultOfApplicationDocument> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultOfApplicationDocument.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultOfApplicationDocument>(<any>null);
    }
}

export interface ITrainingModulesClient {
    /**
     * Create a TrainingModule
     * @param title (optional) 
     */
    create(title: string | null | undefined): Promise<Unit>;
    /**
     * List all TrainingModules
     */
    get(): Promise<TrainingModuleDTO[]>;
    /**
     * List stripped TrainingModules
     */
    getStripped(): Promise<IdValueDtoOfGuid[]>;
    /**
     * List TrainingModule by id
     */
    getById(id: string): Promise<TrainingModule>;
    /**
     * Delete a TrainingModule
     */
    delete(id: string): Promise<Unit>;
}

export class TrainingModulesClient implements ITrainingModulesClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * Create a TrainingModule
     * @param title (optional) 
     */
    create(title: string | null | undefined): Promise<Unit> {
        let url_ = this.baseUrl + "/api/trainingmodules?";
        if (title !== undefined)
            url_ += "title=" + encodeURIComponent("" + title) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processCreate(_response);
        });
    }

    protected processCreate(response: AxiosResponse): Promise<Unit> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Unit.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Unit>(<any>null);
    }

    /**
     * List all TrainingModules
     */
    get(): Promise<TrainingModuleDTO[]> {
        let url_ = this.baseUrl + "/api/trainingmodules";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<TrainingModuleDTO[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TrainingModuleDTO.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TrainingModuleDTO[]>(<any>null);
    }

    /**
     * List stripped TrainingModules
     */
    getStripped(): Promise<IdValueDtoOfGuid[]> {
        let url_ = this.baseUrl + "/api/trainingmodules/stripped";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGetStripped(_response);
        });
    }

    protected processGetStripped(response: AxiosResponse): Promise<IdValueDtoOfGuid[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(IdValueDtoOfGuid.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<IdValueDtoOfGuid[]>(<any>null);
    }

    /**
     * List TrainingModule by id
     */
    getById(id: string): Promise<TrainingModule> {
        let url_ = this.baseUrl + "/api/trainingmodules/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: AxiosResponse): Promise<TrainingModule> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = TrainingModule.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TrainingModule>(<any>null);
    }

    /**
     * Delete a TrainingModule
     */
    delete(id: string): Promise<Unit> {
        let url_ = this.baseUrl + "/api/trainingmodules/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processDelete(_response);
        });
    }

    protected processDelete(response: AxiosResponse): Promise<Unit> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Unit.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Unit>(<any>null);
    }
}

export interface ITrainingsClient {
    /**
     * Get Trainings list
     * @param page (optional) 
     * @param size (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param trainingType (optional) 
     * @param filter (optional) 
     * @param moduleId (optional) 
     */
    get(page: number | null | undefined, size: number | null | undefined, startDate: Date | null | undefined, endDate: Date | null | undefined, trainingType: TrainingType | null | undefined, filter: string | null | undefined, moduleId: string | null | undefined): Promise<PagedResultOfTraining>;
    /**
     * Get Training by id
     */
    getById(id: string): Promise<Training>;
    /**
     * Get Training by id
     */
    getTrainingQuestionsById(id: string): Promise<TrainingQuestion[]>;
    /**
     * Get Training slides by id
     */
    getTrainingSlidesById(id: string): Promise<InteractiveTrainingDocumentVm>;
    /**
     * Create live training
     * @param title (optional) 
     * @param courseURI (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param supportDocument (optional) 
     */
    createLiveTraining(title: string | null | undefined, courseURI: string | null | undefined, startDate: Date | null | undefined, endDate: Date | null | undefined, supportDocument: FileParameter | null | undefined): Promise<Training>;
    /**
     * Edit live training
     * @param title (optional) 
     * @param courseURI (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param supportDocument (optional) 
     */
    editLiveTraining(id: string, title: string | null | undefined, courseURI: string | null | undefined, startDate: Date | null | undefined, endDate: Date | null | undefined, supportDocument: FileParameter | null | undefined): Promise<Training>;
    /**
     * Edit Interactive training
     */
    editInteractiveTraining(id: string, interactiveTrainingDto: InteractiveTrainingDto): Promise<Training>;
    /**
     * Create video training
     */
    createVideoTraining(videoTrainingDto: VideoTrainingDto): Promise<Training>;
    /**
     * Edit video training
     */
    editVideoTraining(id: string, videoTrainingDto: VideoTrainingDto): Promise<Training>;
    /**
     * Create interactive training
     */
    createInteractiveTraining(interactiveTrainingDto: InteractiveTrainingDto): Promise<Training>;
    /**
     * Publish Training
     */
    publish(id: string): Promise<Unit>;
    /**
     * UnPublish Training
     */
    unpublish(id: string): Promise<Unit>;
}

export class TrainingsClient implements ITrainingsClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * Get Trainings list
     * @param page (optional) 
     * @param size (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param trainingType (optional) 
     * @param filter (optional) 
     * @param moduleId (optional) 
     */
    get(page: number | null | undefined, size: number | null | undefined, startDate: Date | null | undefined, endDate: Date | null | undefined, trainingType: TrainingType | null | undefined, filter: string | null | undefined, moduleId: string | null | undefined): Promise<PagedResultOfTraining> {
        let url_ = this.baseUrl + "/api/trainings?";
        if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&"; 
        if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&"; 
        if (startDate !== undefined)
            url_ += "StartDate=" + encodeURIComponent(startDate ? "" + startDate.toJSON() : "") + "&"; 
        if (endDate !== undefined)
            url_ += "EndDate=" + encodeURIComponent(endDate ? "" + endDate.toJSON() : "") + "&"; 
        if (trainingType !== undefined)
            url_ += "TrainingType=" + encodeURIComponent("" + trainingType) + "&"; 
        if (filter !== undefined)
            url_ += "Filter=" + encodeURIComponent("" + filter) + "&"; 
        if (moduleId !== undefined)
            url_ += "ModuleId=" + encodeURIComponent("" + moduleId) + "&"; 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<PagedResultOfTraining> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultOfTraining.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultOfTraining>(<any>null);
    }

    /**
     * Get Training by id
     */
    getById(id: string): Promise<Training> {
        let url_ = this.baseUrl + "/api/trainings/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: AxiosResponse): Promise<Training> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Training.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Training>(<any>null);
    }

    /**
     * Get Training by id
     */
    getTrainingQuestionsById(id: string): Promise<TrainingQuestion[]> {
        let url_ = this.baseUrl + "/api/trainings/{id}/questions";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGetTrainingQuestionsById(_response);
        });
    }

    protected processGetTrainingQuestionsById(response: AxiosResponse): Promise<TrainingQuestion[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(TrainingQuestion.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<TrainingQuestion[]>(<any>null);
    }

    /**
     * Get Training slides by id
     */
    getTrainingSlidesById(id: string): Promise<InteractiveTrainingDocumentVm> {
        let url_ = this.baseUrl + "/api/trainings/{id}/slides";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGetTrainingSlidesById(_response);
        });
    }

    protected processGetTrainingSlidesById(response: AxiosResponse): Promise<InteractiveTrainingDocumentVm> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = InteractiveTrainingDocumentVm.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<InteractiveTrainingDocumentVm>(<any>null);
    }

    /**
     * Create live training
     * @param title (optional) 
     * @param courseURI (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param supportDocument (optional) 
     */
    createLiveTraining(title: string | null | undefined, courseURI: string | null | undefined, startDate: Date | null | undefined, endDate: Date | null | undefined, supportDocument: FileParameter | null | undefined): Promise<Training> {
        let url_ = this.baseUrl + "/api/trainings/live";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (title !== null && title !== undefined)
            content_.append("Title", title.toString());
        if (courseURI !== null && courseURI !== undefined)
            content_.append("CourseURI", courseURI.toString());
        if (startDate !== null && startDate !== undefined)
            content_.append("StartDate", startDate.toJSON());
        if (endDate !== null && endDate !== undefined)
            content_.append("EndDate", endDate.toJSON());
        if (supportDocument !== null && supportDocument !== undefined)
            content_.append("SupportDocument", supportDocument.data, supportDocument.fileName ? supportDocument.fileName : "SupportDocument");

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processCreateLiveTraining(_response);
        });
    }

    protected processCreateLiveTraining(response: AxiosResponse): Promise<Training> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Training.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Training>(<any>null);
    }

    /**
     * Edit live training
     * @param title (optional) 
     * @param courseURI (optional) 
     * @param startDate (optional) 
     * @param endDate (optional) 
     * @param supportDocument (optional) 
     */
    editLiveTraining(id: string, title: string | null | undefined, courseURI: string | null | undefined, startDate: Date | null | undefined, endDate: Date | null | undefined, supportDocument: FileParameter | null | undefined): Promise<Training> {
        let url_ = this.baseUrl + "/api/trainings/live/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (title !== null && title !== undefined)
            content_.append("Title", title.toString());
        if (courseURI !== null && courseURI !== undefined)
            content_.append("CourseURI", courseURI.toString());
        if (startDate !== null && startDate !== undefined)
            content_.append("StartDate", startDate.toJSON());
        if (endDate !== null && endDate !== undefined)
            content_.append("EndDate", endDate.toJSON());
        if (supportDocument !== null && supportDocument !== undefined)
            content_.append("SupportDocument", supportDocument.data, supportDocument.fileName ? supportDocument.fileName : "SupportDocument");

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processEditLiveTraining(_response);
        });
    }

    protected processEditLiveTraining(response: AxiosResponse): Promise<Training> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Training.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Training>(<any>null);
    }

    /**
     * Edit Interactive training
     */
    editInteractiveTraining(id: string, interactiveTrainingDto: InteractiveTrainingDto): Promise<Training> {
        let url_ = this.baseUrl + "/api/trainings/interactive/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(interactiveTrainingDto);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processEditInteractiveTraining(_response);
        });
    }

    protected processEditInteractiveTraining(response: AxiosResponse): Promise<Training> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Training.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Training>(<any>null);
    }

    /**
     * Create video training
     */
    createVideoTraining(videoTrainingDto: VideoTrainingDto): Promise<Training> {
        let url_ = this.baseUrl + "/api/trainings/video";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(videoTrainingDto);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processCreateVideoTraining(_response);
        });
    }

    protected processCreateVideoTraining(response: AxiosResponse): Promise<Training> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Training.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Training>(<any>null);
    }

    /**
     * Edit video training
     */
    editVideoTraining(id: string, videoTrainingDto: VideoTrainingDto): Promise<Training> {
        let url_ = this.baseUrl + "/api/trainings/video/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(videoTrainingDto);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processEditVideoTraining(_response);
        });
    }

    protected processEditVideoTraining(response: AxiosResponse): Promise<Training> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Training.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Training>(<any>null);
    }

    /**
     * Create interactive training
     */
    createInteractiveTraining(interactiveTrainingDto: InteractiveTrainingDto): Promise<Training> {
        let url_ = this.baseUrl + "/api/trainings/interactive";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(interactiveTrainingDto);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processCreateInteractiveTraining(_response);
        });
    }

    protected processCreateInteractiveTraining(response: AxiosResponse): Promise<Training> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Training.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Training>(<any>null);
    }

    /**
     * Publish Training
     */
    publish(id: string): Promise<Unit> {
        let url_ = this.baseUrl + "/api/trainings/{id}/publish";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processPublish(_response);
        });
    }

    protected processPublish(response: AxiosResponse): Promise<Unit> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Unit.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Unit>(<any>null);
    }

    /**
     * UnPublish Training
     */
    unpublish(id: string): Promise<Unit> {
        let url_ = this.baseUrl + "/api/trainings/{id}/unpublish";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processUnpublish(_response);
        });
    }

    protected processUnpublish(response: AxiosResponse): Promise<Unit> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Unit.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Unit>(<any>null);
    }
}

export interface IUsersClient {
    /**
     * Get users list
     * @param page (optional) 
     * @param size (optional) 
     * @param userName (optional) 
     * @param email (optional) 
     * @param firstName (optional) 
     * @param lastName (optional) 
     * @param roleId (optional) 
     * @param isDeactivated (optional) 
     * @param roles (optional) 
     */
    get(page: number | null | undefined, size: number | null | undefined, userName: string | null | undefined, email: string | null | undefined, firstName: string | null | undefined, lastName: string | null | undefined, roleId: string | null | undefined, isDeactivated: boolean | null | undefined, roles: string[] | null | undefined): Promise<PagedResultOfUser>;
    /**
     * Create user
     */
    createUser(userDto: UserDto): Promise<User>;
    /**
     * Get user by id
     */
    getById(id: string | null): Promise<User>;
    /**
     * Delete user
     */
    deleteUser(id: string | null): Promise<Result>;
    /**
     * Update user details
     */
    updateUser(id: string | null, userUpdateDto: UserUpdateDto): Promise<User>;
    /**
     * Get Users by role
     * @param rolenames (optional) User RoleName
     */
    getByRoles(rolenames: string[] | null | undefined): Promise<User[]>;
    /**
     * Get logged in user
     */
    getConnectedUser(): Promise<User>;
    /**
     * Changes usr passuser
     */
    changePassword(changePasswordData: ChangePasswordData): Promise<Unit>;
    /**
     * Update user role
     */
    updateUserRole(userId: string | null, roleName: string | null): Promise<Result>;
    /**
     * Validates a retailer account
     */
    validateRetailer(id: string | null): Promise<Unit>;
    /**
     * Activates a User
     */
    activate(id: string | null): Promise<Unit>;
    /**
     * Deactivate a User
     */
    deactivate(id: string | null): Promise<Unit>;
    /**
     * Init ForgotPassword
     */
    forgotPassword(email: string): Promise<Unit>;
    /**
     * Reset Password
     */
    resetPassword(resetDto: UserResetDto): Promise<Unit>;
}

export class UsersClient implements IUsersClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * Get users list
     * @param page (optional) 
     * @param size (optional) 
     * @param userName (optional) 
     * @param email (optional) 
     * @param firstName (optional) 
     * @param lastName (optional) 
     * @param roleId (optional) 
     * @param isDeactivated (optional) 
     * @param roles (optional) 
     */
    get(page: number | null | undefined, size: number | null | undefined, userName: string | null | undefined, email: string | null | undefined, firstName: string | null | undefined, lastName: string | null | undefined, roleId: string | null | undefined, isDeactivated: boolean | null | undefined, roles: string[] | null | undefined): Promise<PagedResultOfUser> {
        let url_ = this.baseUrl + "/api/users?";
        if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&"; 
        if (size !== undefined)
            url_ += "size=" + encodeURIComponent("" + size) + "&"; 
        if (userName !== undefined)
            url_ += "UserName=" + encodeURIComponent("" + userName) + "&"; 
        if (email !== undefined)
            url_ += "Email=" + encodeURIComponent("" + email) + "&"; 
        if (firstName !== undefined)
            url_ += "FirstName=" + encodeURIComponent("" + firstName) + "&"; 
        if (lastName !== undefined)
            url_ += "LastName=" + encodeURIComponent("" + lastName) + "&"; 
        if (roleId !== undefined)
            url_ += "RoleId=" + encodeURIComponent("" + roleId) + "&"; 
        if (isDeactivated !== undefined)
            url_ += "IsDeactivated=" + encodeURIComponent("" + isDeactivated) + "&"; 
        if (roles !== undefined)
            roles && roles.forEach(item => { url_ += "Roles=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<PagedResultOfUser> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = PagedResultOfUser.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<PagedResultOfUser>(<any>null);
    }

    /**
     * Create user
     */
    createUser(userDto: UserDto): Promise<User> {
        let url_ = this.baseUrl + "/api/users";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(userDto);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processCreateUser(_response);
        });
    }

    protected processCreateUser(response: AxiosResponse): Promise<User> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = User.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<User>(<any>null);
    }

    /**
     * Get user by id
     */
    getById(id: string | null): Promise<User> {
        let url_ = this.baseUrl + "/api/users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGetById(_response);
        });
    }

    protected processGetById(response: AxiosResponse): Promise<User> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = User.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<User>(<any>null);
    }

    /**
     * Delete user
     */
    deleteUser(id: string | null): Promise<Result> {
        let url_ = this.baseUrl + "/api/users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "DELETE",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processDeleteUser(_response);
        });
    }

    protected processDeleteUser(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(<any>null);
    }

    /**
     * Update user details
     */
    updateUser(id: string | null, userUpdateDto: UserUpdateDto): Promise<User> {
        let url_ = this.baseUrl + "/api/users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(userUpdateDto);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "PUT",
            url: url_,
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processUpdateUser(_response);
        });
    }

    protected processUpdateUser(response: AxiosResponse): Promise<User> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = User.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<User>(<any>null);
    }

    /**
     * Get Users by role
     * @param rolenames (optional) User RoleName
     */
    getByRoles(rolenames: string[] | null | undefined): Promise<User[]> {
        let url_ = this.baseUrl + "/api/users/roles?";
        if (rolenames !== undefined)
            rolenames && rolenames.forEach(item => { url_ += "rolenames=" + encodeURIComponent("" + item) + "&"; });
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGetByRoles(_response);
        });
    }

    protected processGetByRoles(response: AxiosResponse): Promise<User[]> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200!.push(User.fromJS(item));
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<User[]>(<any>null);
    }

    /**
     * Get logged in user
     */
    getConnectedUser(): Promise<User> {
        let url_ = this.baseUrl + "/api/users/current";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGetConnectedUser(_response);
        });
    }

    protected processGetConnectedUser(response: AxiosResponse): Promise<User> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = User.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<User>(<any>null);
    }

    /**
     * Changes usr passuser
     */
    changePassword(changePasswordData: ChangePasswordData): Promise<Unit> {
        let url_ = this.baseUrl + "/api/users/password/change";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(changePasswordData);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processChangePassword(_response);
        });
    }

    protected processChangePassword(response: AxiosResponse): Promise<Unit> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Unit.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Unit>(<any>null);
    }

    /**
     * Update user role
     */
    updateUserRole(userId: string | null, roleName: string | null): Promise<Result> {
        let url_ = this.baseUrl + "/api/users/{userId}/{roleName}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId)); 
        if (roleName === undefined || roleName === null)
            throw new Error("The parameter 'roleName' must be defined.");
        url_ = url_.replace("{roleName}", encodeURIComponent("" + roleName)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "PUT",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processUpdateUserRole(_response);
        });
    }

    protected processUpdateUserRole(response: AxiosResponse): Promise<Result> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Result.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Result>(<any>null);
    }

    /**
     * Validates a retailer account
     */
    validateRetailer(id: string | null): Promise<Unit> {
        let url_ = this.baseUrl + "/api/users/{id}/validate";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processValidateRetailer(_response);
        });
    }

    protected processValidateRetailer(response: AxiosResponse): Promise<Unit> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Unit.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Unit>(<any>null);
    }

    /**
     * Activates a User
     */
    activate(id: string | null): Promise<Unit> {
        let url_ = this.baseUrl + "/api/users/{id}/activate";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processActivate(_response);
        });
    }

    protected processActivate(response: AxiosResponse): Promise<Unit> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Unit.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Unit>(<any>null);
    }

    /**
     * Deactivate a User
     */
    deactivate(id: string | null): Promise<Unit> {
        let url_ = this.baseUrl + "/api/users/{id}/deactivate";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id)); 
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "POST",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processDeactivate(_response);
        });
    }

    protected processDeactivate(response: AxiosResponse): Promise<Unit> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Unit.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Unit>(<any>null);
    }

    /**
     * Init ForgotPassword
     */
    forgotPassword(email: string): Promise<Unit> {
        let url_ = this.baseUrl + "/api/users/forgotpassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(email);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processForgotPassword(_response);
        });
    }

    protected processForgotPassword(response: AxiosResponse): Promise<Unit> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Unit.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Unit>(<any>null);
    }

    /**
     * Reset Password
     */
    resetPassword(resetDto: UserResetDto): Promise<Unit> {
        let url_ = this.baseUrl + "/api/users/resetpassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(resetDto);

        let options_ = <AxiosRequestConfig>{
            data: content_,
            method: "POST",
            url: url_,
            headers: {
                "Content-Type": "application/json", 
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processResetPassword(_response);
        });
    }

    protected processResetPassword(response: AxiosResponse): Promise<Unit> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            result200 = Unit.fromJS(resultData200);
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<Unit>(<any>null);
    }
}

export interface IResourcesClient {
    get(): Promise<{ [key: string]: { [key: string]: string; }; }>;
}

export class ResourcesClient implements IResourcesClient {
    private instance: AxiosInstance;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(baseUrl?: string, instance?: AxiosInstance) {
        this.instance = instance ? instance : axios.create();
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    get(): Promise<{ [key: string]: { [key: string]: string; }; }> {
        let url_ = this.baseUrl + "/api/resources";
        url_ = url_.replace(/[?&]$/, "");

        let options_ = <AxiosRequestConfig>{
            method: "GET",
            url: url_,
            headers: {
                "Accept": "application/json"
            }
        };

        return this.instance.request(options_).then((_response: AxiosResponse) => {
            return this.processGet(_response);
        });
    }

    protected processGet(response: AxiosResponse): Promise<{ [key: string]: { [key: string]: string; }; }> {
        const status = response.status;
        let _headers: any = {};
        if (response.headers && typeof response.headers === "object") {
            for (let k in response.headers) {
                if (response.headers.hasOwnProperty(k)) {
                    _headers[k] = response.headers[k];
                }
            }
        }
        if (status === 200) {
            const _responseText = response.data;
            let result200: any = null;
            let resultData200  = _responseText;
            if (resultData200) {
                result200 = {} as any;
                for (let key in resultData200) {
                    if (resultData200.hasOwnProperty(key))
                        result200![key] = resultData200[key] !== undefined ? resultData200[key] : {};
                }
            }
            return result200;
        } else if (status !== 200 && status !== 204) {
            const _responseText = response.data;
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
        }
        return Promise.resolve<{ [key: string]: { [key: string]: string; }; }>(<any>null);
    }
}

export abstract class IdBasedEntityOfGuid implements IIdBasedEntityOfGuid {
    id?: string;

    constructor(data?: IIdBasedEntityOfGuid) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): IdBasedEntityOfGuid {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'IdBasedEntityOfGuid' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface IIdBasedEntityOfGuid {
    id?: string;
}

export abstract class BaseEntityOfGuid extends IdBasedEntityOfGuid implements IBaseEntityOfGuid {
    created?: Date;
    lastModified?: Date | undefined;
    createdBy?: string | undefined;
    lastModifiedBy?: string | undefined;
    isDeleted?: boolean | undefined;

    constructor(data?: IBaseEntityOfGuid) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.lastModified = _data["lastModified"] ? new Date(_data["lastModified"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.lastModifiedBy = _data["lastModifiedBy"];
            this.isDeleted = _data["isDeleted"];
        }
    }

    static fromJS(data: any): BaseEntityOfGuid {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'BaseEntityOfGuid' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["lastModified"] = this.lastModified ? this.lastModified.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["lastModifiedBy"] = this.lastModifiedBy;
        data["isDeleted"] = this.isDeleted;
        super.toJSON(data);
        return data; 
    }
}

export interface IBaseEntityOfGuid extends IIdBasedEntityOfGuid {
    created?: Date;
    lastModified?: Date | undefined;
    createdBy?: string | undefined;
    lastModifiedBy?: string | undefined;
    isDeleted?: boolean | undefined;
}

export class Request extends BaseEntityOfGuid implements IRequest {
    reference?: string | undefined;
    description?: string | undefined;
    requestObject?: string | undefined;
    requestCategoryId?: string;
    requestCategory?: RequestCategory | undefined;
    requestNature?: RequestNatureType;
    processingDirection?: ProcessingDirectionType | undefined;
    lastStatus?: RequestStatusType;
    requestAssignedTo?: RequestAffectationType;
    closingRetailerMessage?: string | undefined;
    closingDescriptionMessage?: string | undefined;
    retailer?: Retailer | undefined;
    retailerId?: string;
    documents?: RequestDocument[] | undefined;
    comments?: RequestComment[] | undefined;
    statuses?: RequestStatus[] | undefined;

    constructor(data?: IRequest) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.reference = _data["reference"];
            this.description = _data["description"];
            this.requestObject = _data["requestObject"];
            this.requestCategoryId = _data["requestCategoryId"];
            this.requestCategory = _data["requestCategory"] ? RequestCategory.fromJS(_data["requestCategory"]) : <any>undefined;
            this.requestNature = _data["requestNature"];
            this.processingDirection = _data["processingDirection"];
            this.lastStatus = _data["lastStatus"];
            this.requestAssignedTo = _data["requestAssignedTo"];
            this.closingRetailerMessage = _data["closingRetailerMessage"];
            this.closingDescriptionMessage = _data["closingDescriptionMessage"];
            this.retailer = _data["retailer"] ? Retailer.fromJS(_data["retailer"]) : <any>undefined;
            this.retailerId = _data["retailerId"];
            if (Array.isArray(_data["documents"])) {
                this.documents = [] as any;
                for (let item of _data["documents"])
                    this.documents!.push(RequestDocument.fromJS(item));
            }
            if (Array.isArray(_data["comments"])) {
                this.comments = [] as any;
                for (let item of _data["comments"])
                    this.comments!.push(RequestComment.fromJS(item));
            }
            if (Array.isArray(_data["statuses"])) {
                this.statuses = [] as any;
                for (let item of _data["statuses"])
                    this.statuses!.push(RequestStatus.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Request {
        data = typeof data === 'object' ? data : {};
        let result = new Request();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reference"] = this.reference;
        data["description"] = this.description;
        data["requestObject"] = this.requestObject;
        data["requestCategoryId"] = this.requestCategoryId;
        data["requestCategory"] = this.requestCategory ? this.requestCategory.toJSON() : <any>undefined;
        data["requestNature"] = this.requestNature;
        data["processingDirection"] = this.processingDirection;
        data["lastStatus"] = this.lastStatus;
        data["requestAssignedTo"] = this.requestAssignedTo;
        data["closingRetailerMessage"] = this.closingRetailerMessage;
        data["closingDescriptionMessage"] = this.closingDescriptionMessage;
        data["retailer"] = this.retailer ? this.retailer.toJSON() : <any>undefined;
        data["retailerId"] = this.retailerId;
        if (Array.isArray(this.documents)) {
            data["documents"] = [];
            for (let item of this.documents)
                data["documents"].push(item.toJSON());
        }
        if (Array.isArray(this.comments)) {
            data["comments"] = [];
            for (let item of this.comments)
                data["comments"].push(item.toJSON());
        }
        if (Array.isArray(this.statuses)) {
            data["statuses"] = [];
            for (let item of this.statuses)
                data["statuses"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IRequest extends IBaseEntityOfGuid {
    reference?: string | undefined;
    description?: string | undefined;
    requestObject?: string | undefined;
    requestCategoryId?: string;
    requestCategory?: RequestCategory | undefined;
    requestNature?: RequestNatureType;
    processingDirection?: ProcessingDirectionType | undefined;
    lastStatus?: RequestStatusType;
    requestAssignedTo?: RequestAffectationType;
    closingRetailerMessage?: string | undefined;
    closingDescriptionMessage?: string | undefined;
    retailer?: Retailer | undefined;
    retailerId?: string;
    documents?: RequestDocument[] | undefined;
    comments?: RequestComment[] | undefined;
    statuses?: RequestStatus[] | undefined;
}

export abstract class AbstractDocument extends BaseEntityOfGuid implements IAbstractDocument {
    uri?: string | undefined;
    data?: string | undefined;
    mimeType?: string | undefined;
    isGenerated?: boolean | undefined;
    type?: DocumentType;
    spec?: DocumentSpec;
    comment?: string | undefined;

    constructor(data?: IAbstractDocument) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.uri = _data["uri"];
            this.data = _data["data"];
            this.mimeType = _data["mimeType"];
            this.isGenerated = _data["isGenerated"];
            this.type = _data["type"];
            this.spec = _data["spec"];
            this.comment = _data["comment"];
        }
    }

    static fromJS(data: any): AbstractDocument {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'AbstractDocument' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["uri"] = this.uri;
        data["data"] = this.data;
        data["mimeType"] = this.mimeType;
        data["isGenerated"] = this.isGenerated;
        data["type"] = this.type;
        data["spec"] = this.spec;
        data["comment"] = this.comment;
        super.toJSON(data);
        return data; 
    }
}

export interface IAbstractDocument extends IBaseEntityOfGuid {
    uri?: string | undefined;
    data?: string | undefined;
    mimeType?: string | undefined;
    isGenerated?: boolean | undefined;
    type?: DocumentType;
    spec?: DocumentSpec;
    comment?: string | undefined;
}

export class RequestCategory extends AbstractDocument implements IRequestCategory {
    requestObjects?: RequestObject[] | undefined;
    title?: string | undefined;
    isDeactivated?: boolean;
    requestNature?: RequestNatureType;

    constructor(data?: IRequestCategory) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["requestObjects"])) {
                this.requestObjects = [] as any;
                for (let item of _data["requestObjects"])
                    this.requestObjects!.push(RequestObject.fromJS(item));
            }
            this.title = _data["title"];
            this.isDeactivated = _data["isDeactivated"];
            this.requestNature = _data["requestNature"];
        }
    }

    static fromJS(data: any): RequestCategory {
        data = typeof data === 'object' ? data : {};
        let result = new RequestCategory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.requestObjects)) {
            data["requestObjects"] = [];
            for (let item of this.requestObjects)
                data["requestObjects"].push(item.toJSON());
        }
        data["title"] = this.title;
        data["isDeactivated"] = this.isDeactivated;
        data["requestNature"] = this.requestNature;
        super.toJSON(data);
        return data; 
    }
}

export interface IRequestCategory extends IAbstractDocument {
    requestObjects?: RequestObject[] | undefined;
    title?: string | undefined;
    isDeactivated?: boolean;
    requestNature?: RequestNatureType;
}

export class RequestObject extends AbstractDocument implements IRequestObject {
    title?: string | undefined;
    isExternal?: boolean | undefined;
    isDeactivated?: boolean;
    requestCategory?: RequestCategory | undefined;
    requestCategoryId?: string;
    processingDirection?: ProcessingDirectionType | undefined;

    constructor(data?: IRequestObject) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.title = _data["title"];
            this.isExternal = _data["isExternal"];
            this.isDeactivated = _data["isDeactivated"];
            this.requestCategory = _data["requestCategory"] ? RequestCategory.fromJS(_data["requestCategory"]) : <any>undefined;
            this.requestCategoryId = _data["requestCategoryId"];
            this.processingDirection = _data["processingDirection"];
        }
    }

    static fromJS(data: any): RequestObject {
        data = typeof data === 'object' ? data : {};
        let result = new RequestObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["isExternal"] = this.isExternal;
        data["isDeactivated"] = this.isDeactivated;
        data["requestCategory"] = this.requestCategory ? this.requestCategory.toJSON() : <any>undefined;
        data["requestCategoryId"] = this.requestCategoryId;
        data["processingDirection"] = this.processingDirection;
        super.toJSON(data);
        return data; 
    }
}

export interface IRequestObject extends IAbstractDocument {
    title?: string | undefined;
    isExternal?: boolean | undefined;
    isDeactivated?: boolean;
    requestCategory?: RequestCategory | undefined;
    requestCategoryId?: string;
    processingDirection?: ProcessingDirectionType | undefined;
}

export enum ProcessingDirectionType {
    DCO = "DCO",
    DMD = "DMD",
    DFS = "DFS",
    DCPRM = "DCPRM",
}

export enum DocumentType {
    TrainingCourseSlide = "TrainingCourseSlide",
    TrainingSupportFile = "TrainingSupportFile",
    TrainingCoverPicture = "TrainingCoverPicture",
    AnnouncementCoverPicture = "AnnouncementCoverPicture",
    OfficialDocument = "OfficialDocument",
    OfficialRessource = "OfficialRessource",
    RequestAudioDocument = "RequestAudioDocument",
    RequestPdfDocument = "RequestPdfDocument",
    RequestImageDocument = "RequestImageDocument",
    RequestObjectCoverPicture = "RequestObjectCoverPicture",
    RequestCategoryCoverPicture = "RequestCategoryCoverPicture",
    RequestNatureCoverPicture = "RequestNatureCoverPicture",
    TrainingCertificate = "TrainingCertificate",
    MediaLibraryDocument = "MediaLibraryDocument",
    ToolboxDocument = "ToolboxDocument",
}

export enum DocumentSpec {
    None = "None",
    AutoGenerated = "AutoGenerated",
    PaperWork = "PaperWork",
}

export enum RequestNatureType {
    Technical = "Technical",
    Administration = "Administration",
    Sales = "Sales",
}

export enum RequestStatusType {
    Submitted = "Submitted",
    InProgress = "InProgress",
    Closed = "Closed",
    Contested = "Contested",
    Cancelled = "Cancelled",
}

export enum RequestAffectationType {
    ExternalAgent = "ExternalAgent",
    InternalAgent = "InternalAgent",
    None = "None",
}

export abstract class ContactBasedEntity extends BaseEntityOfGuid implements IContactBasedEntity {
    city?: string | undefined;
    address?: string | undefined;
    addressLine2?: string | undefined;
    zip?: string | undefined;
    phone?: string | undefined;
    email?: string | undefined;

    constructor(data?: IContactBasedEntity) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.city = _data["city"];
            this.address = _data["address"];
            this.addressLine2 = _data["addressLine2"];
            this.zip = _data["zip"];
            this.phone = _data["phone"];
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): ContactBasedEntity {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'ContactBasedEntity' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["city"] = this.city;
        data["address"] = this.address;
        data["addressLine2"] = this.addressLine2;
        data["zip"] = this.zip;
        data["phone"] = this.phone;
        data["email"] = this.email;
        super.toJSON(data);
        return data; 
    }
}

export interface IContactBasedEntity extends IBaseEntityOfGuid {
    city?: string | undefined;
    address?: string | undefined;
    addressLine2?: string | undefined;
    zip?: string | undefined;
    phone?: string | undefined;
    email?: string | undefined;
}

export class Retailer extends ContactBasedEntity implements IRetailer {
    civility?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    userId?: string | undefined;
    agentId?: string | undefined;
    internalRetailerCode?: string | undefined;
    externalRetailerCode?: string | undefined;
    currentBalance?: number;
    weeklySalesLimit?: number;
    annualCA?: number;
    totalCommissions?: number;
    totalUnpaid?: number;
    contractNumber?: string | undefined;
    companyIdentifier?: string | undefined;
    activity?: string | undefined;
    geographicSector?: string | undefined;
    adressLatitude?: number;
    adressLongitude?: number;
    isNotified?: boolean;
    tradeRegister?: string | undefined;
    professionalTax?: string | undefined;
    gpsCoordinates?: string | undefined;
    commercialZone?: string | undefined;
    geoCodeHCP?: string | undefined;
    municipality?: string | undefined;
    administrativeRegion?: string | undefined;
    sglnCommercialName?: string | undefined;
    sglnCommercialPhone?: string | undefined;
    sglnCommercialMail?: string | undefined;
    taxIdentification?: string | undefined;
    sisalCommercialName?: string | undefined;
    sisalCommercialMail?: string | undefined;
    sisalCommercialPhone?: string | undefined;
    weeksNumber?: number;
    classification?: string | undefined;
    loyalityPoints?: number;
    isDeactivated?: boolean;
    documents?: RetailerDocument[] | undefined;
    invoices?: Invoice[] | undefined;
    retailerNotifications?: RetailerNotification[] | undefined;

    constructor(data?: IRetailer) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.civility = _data["civility"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.userId = _data["userId"];
            this.agentId = _data["agentId"];
            this.internalRetailerCode = _data["internalRetailerCode"];
            this.externalRetailerCode = _data["externalRetailerCode"];
            this.currentBalance = _data["currentBalance"];
            this.weeklySalesLimit = _data["weeklySalesLimit"];
            this.annualCA = _data["annualCA"];
            this.totalCommissions = _data["totalCommissions"];
            this.totalUnpaid = _data["totalUnpaid"];
            this.contractNumber = _data["contractNumber"];
            this.companyIdentifier = _data["companyIdentifier"];
            this.activity = _data["activity"];
            this.geographicSector = _data["geographicSector"];
            this.adressLatitude = _data["adressLatitude"];
            this.adressLongitude = _data["adressLongitude"];
            this.isNotified = _data["isNotified"];
            this.tradeRegister = _data["tradeRegister"];
            this.professionalTax = _data["professionalTax"];
            this.gpsCoordinates = _data["gpsCoordinates"];
            this.commercialZone = _data["commercialZone"];
            this.geoCodeHCP = _data["geoCodeHCP"];
            this.municipality = _data["municipality"];
            this.administrativeRegion = _data["administrativeRegion"];
            this.sglnCommercialName = _data["sglnCommercialName"];
            this.sglnCommercialPhone = _data["sglnCommercialPhone"];
            this.sglnCommercialMail = _data["sglnCommercialMail"];
            this.taxIdentification = _data["taxIdentification"];
            this.sisalCommercialName = _data["sisalCommercialName"];
            this.sisalCommercialMail = _data["sisalCommercialMail"];
            this.sisalCommercialPhone = _data["sisalCommercialPhone"];
            this.weeksNumber = _data["weeksNumber"];
            this.classification = _data["classification"];
            this.loyalityPoints = _data["loyalityPoints"];
            this.isDeactivated = _data["isDeactivated"];
            if (Array.isArray(_data["documents"])) {
                this.documents = [] as any;
                for (let item of _data["documents"])
                    this.documents!.push(RetailerDocument.fromJS(item));
            }
            if (Array.isArray(_data["invoices"])) {
                this.invoices = [] as any;
                for (let item of _data["invoices"])
                    this.invoices!.push(Invoice.fromJS(item));
            }
            if (Array.isArray(_data["retailerNotifications"])) {
                this.retailerNotifications = [] as any;
                for (let item of _data["retailerNotifications"])
                    this.retailerNotifications!.push(RetailerNotification.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Retailer {
        data = typeof data === 'object' ? data : {};
        let result = new Retailer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["civility"] = this.civility;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["userId"] = this.userId;
        data["agentId"] = this.agentId;
        data["internalRetailerCode"] = this.internalRetailerCode;
        data["externalRetailerCode"] = this.externalRetailerCode;
        data["currentBalance"] = this.currentBalance;
        data["weeklySalesLimit"] = this.weeklySalesLimit;
        data["annualCA"] = this.annualCA;
        data["totalCommissions"] = this.totalCommissions;
        data["totalUnpaid"] = this.totalUnpaid;
        data["contractNumber"] = this.contractNumber;
        data["companyIdentifier"] = this.companyIdentifier;
        data["activity"] = this.activity;
        data["geographicSector"] = this.geographicSector;
        data["adressLatitude"] = this.adressLatitude;
        data["adressLongitude"] = this.adressLongitude;
        data["isNotified"] = this.isNotified;
        data["tradeRegister"] = this.tradeRegister;
        data["professionalTax"] = this.professionalTax;
        data["gpsCoordinates"] = this.gpsCoordinates;
        data["commercialZone"] = this.commercialZone;
        data["geoCodeHCP"] = this.geoCodeHCP;
        data["municipality"] = this.municipality;
        data["administrativeRegion"] = this.administrativeRegion;
        data["sglnCommercialName"] = this.sglnCommercialName;
        data["sglnCommercialPhone"] = this.sglnCommercialPhone;
        data["sglnCommercialMail"] = this.sglnCommercialMail;
        data["taxIdentification"] = this.taxIdentification;
        data["sisalCommercialName"] = this.sisalCommercialName;
        data["sisalCommercialMail"] = this.sisalCommercialMail;
        data["sisalCommercialPhone"] = this.sisalCommercialPhone;
        data["weeksNumber"] = this.weeksNumber;
        data["classification"] = this.classification;
        data["loyalityPoints"] = this.loyalityPoints;
        data["isDeactivated"] = this.isDeactivated;
        if (Array.isArray(this.documents)) {
            data["documents"] = [];
            for (let item of this.documents)
                data["documents"].push(item.toJSON());
        }
        if (Array.isArray(this.invoices)) {
            data["invoices"] = [];
            for (let item of this.invoices)
                data["invoices"].push(item.toJSON());
        }
        if (Array.isArray(this.retailerNotifications)) {
            data["retailerNotifications"] = [];
            for (let item of this.retailerNotifications)
                data["retailerNotifications"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IRetailer extends IContactBasedEntity {
    civility?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    userId?: string | undefined;
    agentId?: string | undefined;
    internalRetailerCode?: string | undefined;
    externalRetailerCode?: string | undefined;
    currentBalance?: number;
    weeklySalesLimit?: number;
    annualCA?: number;
    totalCommissions?: number;
    totalUnpaid?: number;
    contractNumber?: string | undefined;
    companyIdentifier?: string | undefined;
    activity?: string | undefined;
    geographicSector?: string | undefined;
    adressLatitude?: number;
    adressLongitude?: number;
    isNotified?: boolean;
    tradeRegister?: string | undefined;
    professionalTax?: string | undefined;
    gpsCoordinates?: string | undefined;
    commercialZone?: string | undefined;
    geoCodeHCP?: string | undefined;
    municipality?: string | undefined;
    administrativeRegion?: string | undefined;
    sglnCommercialName?: string | undefined;
    sglnCommercialPhone?: string | undefined;
    sglnCommercialMail?: string | undefined;
    taxIdentification?: string | undefined;
    sisalCommercialName?: string | undefined;
    sisalCommercialMail?: string | undefined;
    sisalCommercialPhone?: string | undefined;
    weeksNumber?: number;
    classification?: string | undefined;
    loyalityPoints?: number;
    isDeactivated?: boolean;
    documents?: RetailerDocument[] | undefined;
    invoices?: Invoice[] | undefined;
    retailerNotifications?: RetailerNotification[] | undefined;
}

export class RetailerDocument extends AbstractDocument implements IRetailerDocument {
    retailer?: Retailer | undefined;
    retailerId?: string;
    title?: string | undefined;

    constructor(data?: IRetailerDocument) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.retailer = _data["retailer"] ? Retailer.fromJS(_data["retailer"]) : <any>undefined;
            this.retailerId = _data["retailerId"];
            this.title = _data["title"];
        }
    }

    static fromJS(data: any): RetailerDocument {
        data = typeof data === 'object' ? data : {};
        let result = new RetailerDocument();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["retailer"] = this.retailer ? this.retailer.toJSON() : <any>undefined;
        data["retailerId"] = this.retailerId;
        data["title"] = this.title;
        super.toJSON(data);
        return data; 
    }
}

export interface IRetailerDocument extends IAbstractDocument {
    retailer?: Retailer | undefined;
    retailerId?: string;
    title?: string | undefined;
}

export class Invoice extends BaseEntityOfGuid implements IInvoice {
    reference?: string | undefined;
    status?: InvoiceStatusType;
    date?: Date;
    amount?: number;
    retailer?: Retailer | undefined;
    retailerId?: string;

    constructor(data?: IInvoice) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.reference = _data["reference"];
            this.status = _data["status"];
            this.date = _data["date"] ? new Date(_data["date"].toString()) : <any>undefined;
            this.amount = _data["amount"];
            this.retailer = _data["retailer"] ? Retailer.fromJS(_data["retailer"]) : <any>undefined;
            this.retailerId = _data["retailerId"];
        }
    }

    static fromJS(data: any): Invoice {
        data = typeof data === 'object' ? data : {};
        let result = new Invoice();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["reference"] = this.reference;
        data["status"] = this.status;
        data["date"] = this.date ? this.date.toISOString() : <any>undefined;
        data["amount"] = this.amount;
        data["retailer"] = this.retailer ? this.retailer.toJSON() : <any>undefined;
        data["retailerId"] = this.retailerId;
        super.toJSON(data);
        return data; 
    }
}

export interface IInvoice extends IBaseEntityOfGuid {
    reference?: string | undefined;
    status?: InvoiceStatusType;
    date?: Date;
    amount?: number;
    retailer?: Retailer | undefined;
    retailerId?: string;
}

export enum InvoiceStatusType {
    Paid = "Paid",
    Unpaid = "Unpaid",
}

export class RetailerNotification implements IRetailerNotification {
    retailer?: Retailer | undefined;
    retailerId?: string;
    notification?: Notification | undefined;
    notificationId?: string;

    constructor(data?: IRetailerNotification) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.retailer = _data["retailer"] ? Retailer.fromJS(_data["retailer"]) : <any>undefined;
            this.retailerId = _data["retailerId"];
            this.notification = _data["notification"] ? Notification.fromJS(_data["notification"]) : <any>undefined;
            this.notificationId = _data["notificationId"];
        }
    }

    static fromJS(data: any): RetailerNotification {
        data = typeof data === 'object' ? data : {};
        let result = new RetailerNotification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["retailer"] = this.retailer ? this.retailer.toJSON() : <any>undefined;
        data["retailerId"] = this.retailerId;
        data["notification"] = this.notification ? this.notification.toJSON() : <any>undefined;
        data["notificationId"] = this.notificationId;
        return data; 
    }
}

export interface IRetailerNotification {
    retailer?: Retailer | undefined;
    retailerId?: string;
    notification?: Notification | undefined;
    notificationId?: string;
}

export class Notification extends BaseEntityOfGuid implements INotification {
    title?: string | undefined;
    body?: string | undefined;
    type?: NotificationType;
    targetScreen?: NotificationTargetType | undefined;
    targetId?: string | undefined;
    retailerNotifications?: RetailerNotification[] | undefined;

    constructor(data?: INotification) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.title = _data["title"];
            this.body = _data["body"];
            this.type = _data["type"];
            this.targetScreen = _data["targetScreen"];
            this.targetId = _data["targetId"];
            if (Array.isArray(_data["retailerNotifications"])) {
                this.retailerNotifications = [] as any;
                for (let item of _data["retailerNotifications"])
                    this.retailerNotifications!.push(RetailerNotification.fromJS(item));
            }
        }
    }

    static fromJS(data: any): Notification {
        data = typeof data === 'object' ? data : {};
        let result = new Notification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["body"] = this.body;
        data["type"] = this.type;
        data["targetScreen"] = this.targetScreen;
        data["targetId"] = this.targetId;
        if (Array.isArray(this.retailerNotifications)) {
            data["retailerNotifications"] = [];
            for (let item of this.retailerNotifications)
                data["retailerNotifications"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface INotification extends IBaseEntityOfGuid {
    title?: string | undefined;
    body?: string | undefined;
    type?: NotificationType;
    targetScreen?: NotificationTargetType | undefined;
    targetId?: string | undefined;
    retailerNotifications?: RetailerNotification[] | undefined;
}

export enum NotificationType {
    Notification = "Notification",
    Alert = "Alert",
}

export enum NotificationTargetType {
    RequestListScreen = "RequestListScreen",
    CreateRequestScreen = "CreateRequestScreen",
    NewsConsultationList = "NewsConsultationList",
    AnnoucementsDetails = "AnnoucementsDetails",
    TrainingAreaScreen = "TrainingAreaScreen",
    MediaLibraryDocumentScreen = "MediaLibraryDocumentScreen",
    ProfileScreen = "ProfileScreen",
    DocumentsScreen = "DocumentsScreen",
}

export class RequestDocument extends AbstractDocument implements IRequestDocument {
    request?: Request | undefined;
    requestId?: string;

    constructor(data?: IRequestDocument) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.request = _data["request"] ? Request.fromJS(_data["request"]) : <any>undefined;
            this.requestId = _data["requestId"];
        }
    }

    static fromJS(data: any): RequestDocument {
        data = typeof data === 'object' ? data : {};
        let result = new RequestDocument();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["request"] = this.request ? this.request.toJSON() : <any>undefined;
        data["requestId"] = this.requestId;
        super.toJSON(data);
        return data; 
    }
}

export interface IRequestDocument extends IAbstractDocument {
    request?: Request | undefined;
    requestId?: string;
}

export abstract class AbstractComment extends BaseEntityOfGuid implements IAbstractComment {
    body?: string | undefined;

    constructor(data?: IAbstractComment) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.body = _data["body"];
        }
    }

    static fromJS(data: any): AbstractComment {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'AbstractComment' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["body"] = this.body;
        super.toJSON(data);
        return data; 
    }
}

export interface IAbstractComment extends IBaseEntityOfGuid {
    body?: string | undefined;
}

export class RequestComment extends AbstractComment implements IRequestComment {
    request?: Request | undefined;
    requestId?: string;

    constructor(data?: IRequestComment) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.request = _data["request"] ? Request.fromJS(_data["request"]) : <any>undefined;
            this.requestId = _data["requestId"];
        }
    }

    static fromJS(data: any): RequestComment {
        data = typeof data === 'object' ? data : {};
        let result = new RequestComment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["request"] = this.request ? this.request.toJSON() : <any>undefined;
        data["requestId"] = this.requestId;
        super.toJSON(data);
        return data; 
    }
}

export interface IRequestComment extends IAbstractComment {
    request?: Request | undefined;
    requestId?: string;
}

export class RequestStatus extends BaseEntityOfGuid implements IRequestStatus {
    request?: Request | undefined;
    requestId?: string;
    statusType?: RequestStatusType;
    comment?: string | undefined;

    constructor(data?: IRequestStatus) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.request = _data["request"] ? Request.fromJS(_data["request"]) : <any>undefined;
            this.requestId = _data["requestId"];
            this.statusType = _data["statusType"];
            this.comment = _data["comment"];
        }
    }

    static fromJS(data: any): RequestStatus {
        data = typeof data === 'object' ? data : {};
        let result = new RequestStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["request"] = this.request ? this.request.toJSON() : <any>undefined;
        data["requestId"] = this.requestId;
        data["statusType"] = this.statusType;
        data["comment"] = this.comment;
        super.toJSON(data);
        return data; 
    }
}

export interface IRequestStatus extends IBaseEntityOfGuid {
    request?: Request | undefined;
    requestId?: string;
    statusType?: RequestStatusType;
    comment?: string | undefined;
}

export abstract class PagedResultBase implements IPagedResultBase {
    currentPage?: number;
    pageCount?: number;
    pageSize?: number;
    rowCount?: number;
    firstRowOnPage?: number;
    lastRowOnPage?: number;

    constructor(data?: IPagedResultBase) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currentPage = _data["currentPage"];
            this.pageCount = _data["pageCount"];
            this.pageSize = _data["pageSize"];
            this.rowCount = _data["rowCount"];
            this.firstRowOnPage = _data["firstRowOnPage"];
            this.lastRowOnPage = _data["lastRowOnPage"];
        }
    }

    static fromJS(data: any): PagedResultBase {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'PagedResultBase' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentPage"] = this.currentPage;
        data["pageCount"] = this.pageCount;
        data["pageSize"] = this.pageSize;
        data["rowCount"] = this.rowCount;
        data["firstRowOnPage"] = this.firstRowOnPage;
        data["lastRowOnPage"] = this.lastRowOnPage;
        return data; 
    }
}

export interface IPagedResultBase {
    currentPage?: number;
    pageCount?: number;
    pageSize?: number;
    rowCount?: number;
    firstRowOnPage?: number;
    lastRowOnPage?: number;
}

export class PagedResultOfAnnouncement extends PagedResultBase implements IPagedResultOfAnnouncement {
    results?: Announcement[] | undefined;

    constructor(data?: IPagedResultOfAnnouncement) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(Announcement.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultOfAnnouncement {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfAnnouncement();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IPagedResultOfAnnouncement extends IPagedResultBase {
    results?: Announcement[] | undefined;
}

export class Announcement extends AbstractDocument implements IAnnouncement {
    title?: string | undefined;
    body?: string | undefined;
    isPublished?: boolean;

    constructor(data?: IAnnouncement) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.title = _data["title"];
            this.body = _data["body"];
            this.isPublished = _data["isPublished"];
        }
    }

    static fromJS(data: any): Announcement {
        data = typeof data === 'object' ? data : {};
        let result = new Announcement();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["body"] = this.body;
        data["isPublished"] = this.isPublished;
        super.toJSON(data);
        return data; 
    }
}

export interface IAnnouncement extends IAbstractDocument {
    title?: string | undefined;
    body?: string | undefined;
    isPublished?: boolean;
}

export class Unit implements IUnit {

    constructor(data?: IUnit) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): Unit {
        data = typeof data === 'object' ? data : {};
        let result = new Unit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data; 
    }
}

export interface IUnit {
}

export class AuthenticationResult implements IAuthenticationResult {
    succeeded?: boolean;
    isLockedOut?: boolean;
    isNotAllowed?: boolean;
    accessToken?: string | undefined;
    isTemporaryPassword?: boolean;
    errors?: string[] | undefined;

    constructor(data?: IAuthenticationResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.succeeded = _data["succeeded"];
            this.isLockedOut = _data["isLockedOut"];
            this.isNotAllowed = _data["isNotAllowed"];
            this.accessToken = _data["accessToken"];
            this.isTemporaryPassword = _data["isTemporaryPassword"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): AuthenticationResult {
        data = typeof data === 'object' ? data : {};
        let result = new AuthenticationResult();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["succeeded"] = this.succeeded;
        data["isLockedOut"] = this.isLockedOut;
        data["isNotAllowed"] = this.isNotAllowed;
        data["accessToken"] = this.accessToken;
        data["isTemporaryPassword"] = this.isTemporaryPassword;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data; 
    }
}

export interface IAuthenticationResult {
    succeeded?: boolean;
    isLockedOut?: boolean;
    isNotAllowed?: boolean;
    accessToken?: string | undefined;
    isTemporaryPassword?: boolean;
    errors?: string[] | undefined;
}

export class UserSignInDto implements IUserSignInDto {
    userName!: string;
    password!: string;
    deviceToken?: string | undefined;

    constructor(data?: IUserSignInDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userName = _data["userName"];
            this.password = _data["password"];
            this.deviceToken = _data["deviceToken"];
        }
    }

    static fromJS(data: any): UserSignInDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserSignInDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userName"] = this.userName;
        data["password"] = this.password;
        data["deviceToken"] = this.deviceToken;
        return data; 
    }
}

export interface IUserSignInDto {
    userName: string;
    password: string;
    deviceToken?: string | undefined;
}

export class IdValueDtoOfInteger implements IIdValueDtoOfInteger {
    id?: number;
    value?: string | undefined;

    constructor(data?: IIdValueDtoOfInteger) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): IdValueDtoOfInteger {
        data = typeof data === 'object' ? data : {};
        let result = new IdValueDtoOfInteger();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["value"] = this.value;
        return data; 
    }
}

export interface IIdValueDtoOfInteger {
    id?: number;
    value?: string | undefined;
}

export abstract class IdBasedEntityOfInteger implements IIdBasedEntityOfInteger {
    id?: number;

    constructor(data?: IIdBasedEntityOfInteger) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): IdBasedEntityOfInteger {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'IdBasedEntityOfInteger' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        return data; 
    }
}

export interface IIdBasedEntityOfInteger {
    id?: number;
}

export abstract class BaseEntityOfInteger extends IdBasedEntityOfInteger implements IBaseEntityOfInteger {
    created?: Date;
    lastModified?: Date | undefined;
    createdBy?: string | undefined;
    lastModifiedBy?: string | undefined;
    isDeleted?: boolean | undefined;

    constructor(data?: IBaseEntityOfInteger) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.lastModified = _data["lastModified"] ? new Date(_data["lastModified"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.lastModifiedBy = _data["lastModifiedBy"];
            this.isDeleted = _data["isDeleted"];
        }
    }

    static fromJS(data: any): BaseEntityOfInteger {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'BaseEntityOfInteger' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["lastModified"] = this.lastModified ? this.lastModified.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["lastModifiedBy"] = this.lastModifiedBy;
        data["isDeleted"] = this.isDeleted;
        super.toJSON(data);
        return data; 
    }
}

export interface IBaseEntityOfInteger extends IIdBasedEntityOfInteger {
    created?: Date;
    lastModified?: Date | undefined;
    createdBy?: string | undefined;
    lastModifiedBy?: string | undefined;
    isDeleted?: boolean | undefined;
}

export abstract class TitledData extends BaseEntityOfInteger implements ITitledData {
    title?: string | undefined;
    normalizedTitle?: string | undefined;

    constructor(data?: ITitledData) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.title = _data["title"];
            this.normalizedTitle = _data["normalizedTitle"];
        }
    }

    static fromJS(data: any): TitledData {
        data = typeof data === 'object' ? data : {};
        throw new Error("The abstract class 'TitledData' cannot be instantiated.");
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["normalizedTitle"] = this.normalizedTitle;
        super.toJSON(data);
        return data; 
    }
}

export interface ITitledData extends IBaseEntityOfInteger {
    title?: string | undefined;
    normalizedTitle?: string | undefined;
}

export class City extends TitledData implements ICity {

    constructor(data?: ICity) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
    }

    static fromJS(data: any): City {
        data = typeof data === 'object' ? data : {};
        let result = new City();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data; 
    }
}

export interface ICity extends ITitledData {
}

export class RetailerDto implements IRetailerDto {
    civility?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    phone?: string | undefined;
    email?: string | undefined;
    address?: string | undefined;
    internalRetailerCode?: string | undefined;
    externalRetailerCode?: string | undefined;
    weeklySalesLimit?: number;
    annualCA?: number;
    totalCommissions?: number;
    totalUnpaid?: number;
    contractNumber?: string | undefined;
    companyIdentifier?: string | undefined;
    activity?: string | undefined;
    geographicSector?: string | undefined;
    adressLatitude?: number;
    adressLongitude?: number;
    agentEmail?: string | undefined;
    tradeRegister?: string | undefined;
    professionalTax?: string | undefined;
    gpsCoordinates?: string | undefined;
    commercialZone?: string | undefined;
    geoCodeHCP?: string | undefined;
    municipality?: string | undefined;
    administrativeRegion?: string | undefined;
    sglnCommercialName?: string | undefined;
    sglnCommercialPhone?: string | undefined;

    constructor(data?: IRetailerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.civility = _data["civility"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.phone = _data["phone"];
            this.email = _data["email"];
            this.address = _data["address"];
            this.internalRetailerCode = _data["internalRetailerCode"];
            this.externalRetailerCode = _data["externalRetailerCode"];
            this.weeklySalesLimit = _data["weeklySalesLimit"];
            this.annualCA = _data["annualCA"];
            this.totalCommissions = _data["totalCommissions"];
            this.totalUnpaid = _data["totalUnpaid"];
            this.contractNumber = _data["contractNumber"];
            this.companyIdentifier = _data["companyIdentifier"];
            this.activity = _data["activity"];
            this.geographicSector = _data["geographicSector"];
            this.adressLatitude = _data["adressLatitude"];
            this.adressLongitude = _data["adressLongitude"];
            this.agentEmail = _data["agentEmail"];
            this.tradeRegister = _data["tradeRegister"];
            this.professionalTax = _data["professionalTax"];
            this.gpsCoordinates = _data["gpsCoordinates"];
            this.commercialZone = _data["commercialZone"];
            this.geoCodeHCP = _data["geoCodeHCP"];
            this.municipality = _data["municipality"];
            this.administrativeRegion = _data["administrativeRegion"];
            this.sglnCommercialName = _data["sglnCommercialName"];
            this.sglnCommercialPhone = _data["sglnCommercialPhone"];
        }
    }

    static fromJS(data: any): RetailerDto {
        data = typeof data === 'object' ? data : {};
        let result = new RetailerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["civility"] = this.civility;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["phone"] = this.phone;
        data["email"] = this.email;
        data["address"] = this.address;
        data["internalRetailerCode"] = this.internalRetailerCode;
        data["externalRetailerCode"] = this.externalRetailerCode;
        data["weeklySalesLimit"] = this.weeklySalesLimit;
        data["annualCA"] = this.annualCA;
        data["totalCommissions"] = this.totalCommissions;
        data["totalUnpaid"] = this.totalUnpaid;
        data["contractNumber"] = this.contractNumber;
        data["companyIdentifier"] = this.companyIdentifier;
        data["activity"] = this.activity;
        data["geographicSector"] = this.geographicSector;
        data["adressLatitude"] = this.adressLatitude;
        data["adressLongitude"] = this.adressLongitude;
        data["agentEmail"] = this.agentEmail;
        data["tradeRegister"] = this.tradeRegister;
        data["professionalTax"] = this.professionalTax;
        data["gpsCoordinates"] = this.gpsCoordinates;
        data["commercialZone"] = this.commercialZone;
        data["geoCodeHCP"] = this.geoCodeHCP;
        data["municipality"] = this.municipality;
        data["administrativeRegion"] = this.administrativeRegion;
        data["sglnCommercialName"] = this.sglnCommercialName;
        data["sglnCommercialPhone"] = this.sglnCommercialPhone;
        return data; 
    }
}

export interface IRetailerDto {
    civility?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    phone?: string | undefined;
    email?: string | undefined;
    address?: string | undefined;
    internalRetailerCode?: string | undefined;
    externalRetailerCode?: string | undefined;
    weeklySalesLimit?: number;
    annualCA?: number;
    totalCommissions?: number;
    totalUnpaid?: number;
    contractNumber?: string | undefined;
    companyIdentifier?: string | undefined;
    activity?: string | undefined;
    geographicSector?: string | undefined;
    adressLatitude?: number;
    adressLongitude?: number;
    agentEmail?: string | undefined;
    tradeRegister?: string | undefined;
    professionalTax?: string | undefined;
    gpsCoordinates?: string | undefined;
    commercialZone?: string | undefined;
    geoCodeHCP?: string | undefined;
    municipality?: string | undefined;
    administrativeRegion?: string | undefined;
    sglnCommercialName?: string | undefined;
    sglnCommercialPhone?: string | undefined;
}

export class RetailerUpdateDto implements IRetailerUpdateDto {
    civility?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    phone?: string | undefined;
    email?: string | undefined;
    address?: string | undefined;
    internalRetailerCode?: string | undefined;
    externalRetailerCode?: string | undefined;
    weeklySalesLimit?: number | undefined;
    annualCA?: number | undefined;
    totalCommissions?: number | undefined;
    totalUnpaid?: number | undefined;
    contractNumber?: string | undefined;
    companyIdentifier?: string | undefined;
    activity?: string | undefined;
    geographicSector?: string | undefined;
    adressLatitude?: number | undefined;
    adressLongitude?: number | undefined;
    agentEmail?: string | undefined;
    tradeRegister?: string | undefined;
    professionalTax?: string | undefined;
    gpsCoordinates?: string | undefined;
    commercialZone?: string | undefined;
    geoCodeHCP?: string | undefined;
    municipality?: string | undefined;
    administrativeRegion?: string | undefined;
    sglnCommercialName?: string | undefined;
    sglnCommercialPhone?: string | undefined;
    sglnCommercialMail?: string | undefined;
    sisalCommercialName?: string | undefined;
    sisalCommercialMail?: string | undefined;

    constructor(data?: IRetailerUpdateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.civility = _data["civility"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.phone = _data["phone"];
            this.email = _data["email"];
            this.address = _data["address"];
            this.internalRetailerCode = _data["internalRetailerCode"];
            this.externalRetailerCode = _data["externalRetailerCode"];
            this.weeklySalesLimit = _data["weeklySalesLimit"];
            this.annualCA = _data["annualCA"];
            this.totalCommissions = _data["totalCommissions"];
            this.totalUnpaid = _data["totalUnpaid"];
            this.contractNumber = _data["contractNumber"];
            this.companyIdentifier = _data["companyIdentifier"];
            this.activity = _data["activity"];
            this.geographicSector = _data["geographicSector"];
            this.adressLatitude = _data["adressLatitude"];
            this.adressLongitude = _data["adressLongitude"];
            this.agentEmail = _data["agentEmail"];
            this.tradeRegister = _data["tradeRegister"];
            this.professionalTax = _data["professionalTax"];
            this.gpsCoordinates = _data["gpsCoordinates"];
            this.commercialZone = _data["commercialZone"];
            this.geoCodeHCP = _data["geoCodeHCP"];
            this.municipality = _data["municipality"];
            this.administrativeRegion = _data["administrativeRegion"];
            this.sglnCommercialName = _data["sglnCommercialName"];
            this.sglnCommercialPhone = _data["sglnCommercialPhone"];
            this.sglnCommercialMail = _data["sglnCommercialMail"];
            this.sisalCommercialName = _data["sisalCommercialName"];
            this.sisalCommercialMail = _data["sisalCommercialMail"];
        }
    }

    static fromJS(data: any): RetailerUpdateDto {
        data = typeof data === 'object' ? data : {};
        let result = new RetailerUpdateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["civility"] = this.civility;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["phone"] = this.phone;
        data["email"] = this.email;
        data["address"] = this.address;
        data["internalRetailerCode"] = this.internalRetailerCode;
        data["externalRetailerCode"] = this.externalRetailerCode;
        data["weeklySalesLimit"] = this.weeklySalesLimit;
        data["annualCA"] = this.annualCA;
        data["totalCommissions"] = this.totalCommissions;
        data["totalUnpaid"] = this.totalUnpaid;
        data["contractNumber"] = this.contractNumber;
        data["companyIdentifier"] = this.companyIdentifier;
        data["activity"] = this.activity;
        data["geographicSector"] = this.geographicSector;
        data["adressLatitude"] = this.adressLatitude;
        data["adressLongitude"] = this.adressLongitude;
        data["agentEmail"] = this.agentEmail;
        data["tradeRegister"] = this.tradeRegister;
        data["professionalTax"] = this.professionalTax;
        data["gpsCoordinates"] = this.gpsCoordinates;
        data["commercialZone"] = this.commercialZone;
        data["geoCodeHCP"] = this.geoCodeHCP;
        data["municipality"] = this.municipality;
        data["administrativeRegion"] = this.administrativeRegion;
        data["sglnCommercialName"] = this.sglnCommercialName;
        data["sglnCommercialPhone"] = this.sglnCommercialPhone;
        data["sglnCommercialMail"] = this.sglnCommercialMail;
        data["sisalCommercialName"] = this.sisalCommercialName;
        data["sisalCommercialMail"] = this.sisalCommercialMail;
        return data; 
    }
}

export interface IRetailerUpdateDto {
    civility?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    phone?: string | undefined;
    email?: string | undefined;
    address?: string | undefined;
    internalRetailerCode?: string | undefined;
    externalRetailerCode?: string | undefined;
    weeklySalesLimit?: number | undefined;
    annualCA?: number | undefined;
    totalCommissions?: number | undefined;
    totalUnpaid?: number | undefined;
    contractNumber?: string | undefined;
    companyIdentifier?: string | undefined;
    activity?: string | undefined;
    geographicSector?: string | undefined;
    adressLatitude?: number | undefined;
    adressLongitude?: number | undefined;
    agentEmail?: string | undefined;
    tradeRegister?: string | undefined;
    professionalTax?: string | undefined;
    gpsCoordinates?: string | undefined;
    commercialZone?: string | undefined;
    geoCodeHCP?: string | undefined;
    municipality?: string | undefined;
    administrativeRegion?: string | undefined;
    sglnCommercialName?: string | undefined;
    sglnCommercialPhone?: string | undefined;
    sglnCommercialMail?: string | undefined;
    sisalCommercialName?: string | undefined;
    sisalCommercialMail?: string | undefined;
}

export class DocumentDto implements IDocumentDto {
    id?: string | undefined;
    type?: DocumentType;
    spec?: DocumentSpec;
    mimeType?: string | undefined;
    created?: Date;
    comment?: string | undefined;

    constructor(data?: IDocumentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.type = _data["type"];
            this.spec = _data["spec"];
            this.mimeType = _data["mimeType"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.comment = _data["comment"];
        }
    }

    static fromJS(data: any): DocumentDto {
        data = typeof data === 'object' ? data : {};
        let result = new DocumentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["type"] = this.type;
        data["spec"] = this.spec;
        data["mimeType"] = this.mimeType;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["comment"] = this.comment;
        return data; 
    }
}

export interface IDocumentDto {
    id?: string | undefined;
    type?: DocumentType;
    spec?: DocumentSpec;
    mimeType?: string | undefined;
    created?: Date;
    comment?: string | undefined;
}

export class IncentiveDto implements IIncentiveDto {
    type?: GameType;
    startDate?: string | undefined;
    endDate?: string | undefined;
    goal?: number;
    achievement?: number;
    achievementRate?: number;
    remains?: number;
    bonus?: number;

    constructor(data?: IIncentiveDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            this.startDate = _data["startDate"];
            this.endDate = _data["endDate"];
            this.goal = _data["goal"];
            this.achievement = _data["achievement"];
            this.achievementRate = _data["achievementRate"];
            this.remains = _data["remains"];
            this.bonus = _data["bonus"];
        }
    }

    static fromJS(data: any): IncentiveDto {
        data = typeof data === 'object' ? data : {};
        let result = new IncentiveDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        data["startDate"] = this.startDate;
        data["endDate"] = this.endDate;
        data["goal"] = this.goal;
        data["achievement"] = this.achievement;
        data["achievementRate"] = this.achievementRate;
        data["remains"] = this.remains;
        data["bonus"] = this.bonus;
        return data; 
    }
}

export interface IIncentiveDto {
    type?: GameType;
    startDate?: string | undefined;
    endDate?: string | undefined;
    goal?: number;
    achievement?: number;
    achievementRate?: number;
    remains?: number;
    bonus?: number;
}

export enum GameType {
    Loto = "Loto",
    Joker = "Joker",
    Keno = "Keno",
    Quatro = "Quatro",
}

export class PagedResultOfNotification extends PagedResultBase implements IPagedResultOfNotification {
    results?: Notification[] | undefined;

    constructor(data?: IPagedResultOfNotification) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(Notification.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultOfNotification {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfNotification();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IPagedResultOfNotification extends IPagedResultBase {
    results?: Notification[] | undefined;
}

export class IdValueDtoOfGuid implements IIdValueDtoOfGuid {
    id?: string;
    value?: string | undefined;

    constructor(data?: IIdValueDtoOfGuid) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.value = _data["value"];
        }
    }

    static fromJS(data: any): IdValueDtoOfGuid {
        data = typeof data === 'object' ? data : {};
        let result = new IdValueDtoOfGuid();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["value"] = this.value;
        return data; 
    }
}

export interface IIdValueDtoOfGuid {
    id?: string;
    value?: string | undefined;
}

export class NotificationDto implements INotificationDto {
    title?: string | undefined;
    body?: string | undefined;
    type?: NotificationType;
    targetRetailerIds?: string[] | undefined;
    targetScreen?: NotificationTargetType | undefined;
    targetId?: string | undefined;

    constructor(data?: INotificationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.body = _data["body"];
            this.type = _data["type"];
            if (Array.isArray(_data["targetRetailerIds"])) {
                this.targetRetailerIds = [] as any;
                for (let item of _data["targetRetailerIds"])
                    this.targetRetailerIds!.push(item);
            }
            this.targetScreen = _data["targetScreen"];
            this.targetId = _data["targetId"];
        }
    }

    static fromJS(data: any): NotificationDto {
        data = typeof data === 'object' ? data : {};
        let result = new NotificationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["body"] = this.body;
        data["type"] = this.type;
        if (Array.isArray(this.targetRetailerIds)) {
            data["targetRetailerIds"] = [];
            for (let item of this.targetRetailerIds)
                data["targetRetailerIds"].push(item);
        }
        data["targetScreen"] = this.targetScreen;
        data["targetId"] = this.targetId;
        return data; 
    }
}

export interface INotificationDto {
    title?: string | undefined;
    body?: string | undefined;
    type?: NotificationType;
    targetRetailerIds?: string[] | undefined;
    targetScreen?: NotificationTargetType | undefined;
    targetId?: string | undefined;
}

export enum DocumentFormat {
    Pdf = "Pdf",
    Excel = "Excel",
}

export class RetailersReportDto implements IRetailersReportDto {
    countActiveRetailers?: number;
    countRegisteredRetailers?: number;
    ratioActiveRegistered?: number;

    constructor(data?: IRetailersReportDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.countActiveRetailers = _data["countActiveRetailers"];
            this.countRegisteredRetailers = _data["countRegisteredRetailers"];
            this.ratioActiveRegistered = _data["ratioActiveRegistered"];
        }
    }

    static fromJS(data: any): RetailersReportDto {
        data = typeof data === 'object' ? data : {};
        let result = new RetailersReportDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["countActiveRetailers"] = this.countActiveRetailers;
        data["countRegisteredRetailers"] = this.countRegisteredRetailers;
        data["ratioActiveRegistered"] = this.ratioActiveRegistered;
        return data; 
    }
}

export interface IRetailersReportDto {
    countActiveRetailers?: number;
    countRegisteredRetailers?: number;
    ratioActiveRegistered?: number;
}

export class PagedResultOfRequestCategory extends PagedResultBase implements IPagedResultOfRequestCategory {
    results?: RequestCategory[] | undefined;

    constructor(data?: IPagedResultOfRequestCategory) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(RequestCategory.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultOfRequestCategory {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfRequestCategory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IPagedResultOfRequestCategory extends IPagedResultBase {
    results?: RequestCategory[] | undefined;
}

export class RequestCommentDto implements IRequestCommentDto {
    body?: string | undefined;
    requestId?: string;

    constructor(data?: IRequestCommentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.body = _data["body"];
            this.requestId = _data["requestId"];
        }
    }

    static fromJS(data: any): RequestCommentDto {
        data = typeof data === 'object' ? data : {};
        let result = new RequestCommentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["body"] = this.body;
        data["requestId"] = this.requestId;
        return data; 
    }
}

export interface IRequestCommentDto {
    body?: string | undefined;
    requestId?: string;
}

export class PagedResultOfRequestObject extends PagedResultBase implements IPagedResultOfRequestObject {
    results?: RequestObject[] | undefined;

    constructor(data?: IPagedResultOfRequestObject) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(RequestObject.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultOfRequestObject {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfRequestObject();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IPagedResultOfRequestObject extends IPagedResultBase {
    results?: RequestObject[] | undefined;
}

export class PagedResultOfRequest extends PagedResultBase implements IPagedResultOfRequest {
    results?: Request[] | undefined;

    constructor(data?: IPagedResultOfRequest) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(Request.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultOfRequest {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IPagedResultOfRequest extends IPagedResultBase {
    results?: Request[] | undefined;
}

export class CloseRequestDto implements ICloseRequestDto {
    closingRetailerMessage?: string | undefined;
    closingDescriptionMessage?: string | undefined;

    constructor(data?: ICloseRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.closingRetailerMessage = _data["closingRetailerMessage"];
            this.closingDescriptionMessage = _data["closingDescriptionMessage"];
        }
    }

    static fromJS(data: any): CloseRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new CloseRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["closingRetailerMessage"] = this.closingRetailerMessage;
        data["closingDescriptionMessage"] = this.closingDescriptionMessage;
        return data; 
    }
}

export interface ICloseRequestDto {
    closingRetailerMessage?: string | undefined;
    closingDescriptionMessage?: string | undefined;
}

export class PagedResultOfRetailer extends PagedResultBase implements IPagedResultOfRetailer {
    results?: Retailer[] | undefined;

    constructor(data?: IPagedResultOfRetailer) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(Retailer.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultOfRetailer {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfRetailer();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IPagedResultOfRetailer extends IPagedResultBase {
    results?: Retailer[] | undefined;
}

export class GetRetailerDto implements IGetRetailerDto {
    civility?: string | undefined;
    userid?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    phone?: string | undefined;
    email?: string | undefined;
    address?: string | undefined;
    internalRetailerCode?: string | undefined;
    externalRetailerCode?: string | undefined;
    weeklySalesLimit?: number;
    annualCA?: number;
    totalCommissions?: number;
    totalUnpaid?: number;
    contractNumber?: string | undefined;
    companyIdentifier?: string | undefined;
    activity?: string | undefined;
    geographicSector?: string | undefined;
    isDeactivated?: boolean;
    isValidated?: boolean;
    sglnCommercialName?: string | undefined;
    sglnCommercialPhone?: string | undefined;
    sglnCommercialMail?: string | undefined;
    sisalCommercialName?: string | undefined;
    sisalCommercialMail?: string | undefined;
    sisalCommercialPhone?: string | undefined;

    constructor(data?: IGetRetailerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.civility = _data["civility"];
            this.userid = _data["userid"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.phone = _data["phone"];
            this.email = _data["email"];
            this.address = _data["address"];
            this.internalRetailerCode = _data["internalRetailerCode"];
            this.externalRetailerCode = _data["externalRetailerCode"];
            this.weeklySalesLimit = _data["weeklySalesLimit"];
            this.annualCA = _data["annualCA"];
            this.totalCommissions = _data["totalCommissions"];
            this.totalUnpaid = _data["totalUnpaid"];
            this.contractNumber = _data["contractNumber"];
            this.companyIdentifier = _data["companyIdentifier"];
            this.activity = _data["activity"];
            this.geographicSector = _data["geographicSector"];
            this.isDeactivated = _data["isDeactivated"];
            this.isValidated = _data["isValidated"];
            this.sglnCommercialName = _data["sglnCommercialName"];
            this.sglnCommercialPhone = _data["sglnCommercialPhone"];
            this.sglnCommercialMail = _data["sglnCommercialMail"];
            this.sisalCommercialName = _data["sisalCommercialName"];
            this.sisalCommercialMail = _data["sisalCommercialMail"];
            this.sisalCommercialPhone = _data["sisalCommercialPhone"];
        }
    }

    static fromJS(data: any): GetRetailerDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetRetailerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["civility"] = this.civility;
        data["userid"] = this.userid;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["phone"] = this.phone;
        data["email"] = this.email;
        data["address"] = this.address;
        data["internalRetailerCode"] = this.internalRetailerCode;
        data["externalRetailerCode"] = this.externalRetailerCode;
        data["weeklySalesLimit"] = this.weeklySalesLimit;
        data["annualCA"] = this.annualCA;
        data["totalCommissions"] = this.totalCommissions;
        data["totalUnpaid"] = this.totalUnpaid;
        data["contractNumber"] = this.contractNumber;
        data["companyIdentifier"] = this.companyIdentifier;
        data["activity"] = this.activity;
        data["geographicSector"] = this.geographicSector;
        data["isDeactivated"] = this.isDeactivated;
        data["isValidated"] = this.isValidated;
        data["sglnCommercialName"] = this.sglnCommercialName;
        data["sglnCommercialPhone"] = this.sglnCommercialPhone;
        data["sglnCommercialMail"] = this.sglnCommercialMail;
        data["sisalCommercialName"] = this.sisalCommercialName;
        data["sisalCommercialMail"] = this.sisalCommercialMail;
        data["sisalCommercialPhone"] = this.sisalCommercialPhone;
        return data; 
    }
}

export interface IGetRetailerDto {
    civility?: string | undefined;
    userid?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    phone?: string | undefined;
    email?: string | undefined;
    address?: string | undefined;
    internalRetailerCode?: string | undefined;
    externalRetailerCode?: string | undefined;
    weeklySalesLimit?: number;
    annualCA?: number;
    totalCommissions?: number;
    totalUnpaid?: number;
    contractNumber?: string | undefined;
    companyIdentifier?: string | undefined;
    activity?: string | undefined;
    geographicSector?: string | undefined;
    isDeactivated?: boolean;
    isValidated?: boolean;
    sglnCommercialName?: string | undefined;
    sglnCommercialPhone?: string | undefined;
    sglnCommercialMail?: string | undefined;
    sisalCommercialName?: string | undefined;
    sisalCommercialMail?: string | undefined;
    sisalCommercialPhone?: string | undefined;
}

export class User implements IUser {
    id?: string | undefined;
    email?: string | undefined;
    userName?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    phoneNumber?: string | undefined;
    emailConfirmed?: boolean | undefined;
    phoneNumberConfirmed?: boolean | undefined;
    createdBy?: string | undefined;
    created?: Date;
    lastModifiedBy?: string | undefined;
    lastModified?: Date | undefined;
    isExternal?: boolean | undefined;
    isDeleted?: boolean | undefined;
    isDeactivated?: boolean;
    isValidated?: boolean;
    administration?: ProcessingDirectionType | undefined;
    roleName?: string | undefined;
    permissions?: string[] | undefined;

    constructor(data?: IUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.email = _data["email"];
            this.userName = _data["userName"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.phoneNumber = _data["phoneNumber"];
            this.emailConfirmed = _data["emailConfirmed"];
            this.phoneNumberConfirmed = _data["phoneNumberConfirmed"];
            this.createdBy = _data["createdBy"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
            this.lastModifiedBy = _data["lastModifiedBy"];
            this.lastModified = _data["lastModified"] ? new Date(_data["lastModified"].toString()) : <any>undefined;
            this.isExternal = _data["isExternal"];
            this.isDeleted = _data["isDeleted"];
            this.isDeactivated = _data["isDeactivated"];
            this.isValidated = _data["isValidated"];
            this.administration = _data["administration"];
            this.roleName = _data["roleName"];
            if (Array.isArray(_data["permissions"])) {
                this.permissions = [] as any;
                for (let item of _data["permissions"])
                    this.permissions!.push(item);
            }
        }
    }

    static fromJS(data: any): User {
        data = typeof data === 'object' ? data : {};
        let result = new User();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["email"] = this.email;
        data["userName"] = this.userName;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["phoneNumber"] = this.phoneNumber;
        data["emailConfirmed"] = this.emailConfirmed;
        data["phoneNumberConfirmed"] = this.phoneNumberConfirmed;
        data["createdBy"] = this.createdBy;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        data["lastModifiedBy"] = this.lastModifiedBy;
        data["lastModified"] = this.lastModified ? this.lastModified.toISOString() : <any>undefined;
        data["isExternal"] = this.isExternal;
        data["isDeleted"] = this.isDeleted;
        data["isDeactivated"] = this.isDeactivated;
        data["isValidated"] = this.isValidated;
        data["administration"] = this.administration;
        data["roleName"] = this.roleName;
        if (Array.isArray(this.permissions)) {
            data["permissions"] = [];
            for (let item of this.permissions)
                data["permissions"].push(item);
        }
        return data; 
    }
}

export interface IUser {
    id?: string | undefined;
    email?: string | undefined;
    userName?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    phoneNumber?: string | undefined;
    emailConfirmed?: boolean | undefined;
    phoneNumberConfirmed?: boolean | undefined;
    createdBy?: string | undefined;
    created?: Date;
    lastModifiedBy?: string | undefined;
    lastModified?: Date | undefined;
    isExternal?: boolean | undefined;
    isDeleted?: boolean | undefined;
    isDeactivated?: boolean;
    isValidated?: boolean;
    administration?: ProcessingDirectionType | undefined;
    roleName?: string | undefined;
    permissions?: string[] | undefined;
}

export class SalesRepresentativeDto implements ISalesRepresentativeDto {
    sglnCommercialName?: string | undefined;
    sglnCommercialMail?: string | undefined;
    sglnCommercialPhone?: string | undefined;
    sisalCommercialName?: string | undefined;
    sisalCommercialMail?: string | undefined;
    sisalCommercialPhone?: string | undefined;
    isMassAssignement?: boolean;
    targetMunicipality?: string | undefined;

    constructor(data?: ISalesRepresentativeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sglnCommercialName = _data["sglnCommercialName"];
            this.sglnCommercialMail = _data["sglnCommercialMail"];
            this.sglnCommercialPhone = _data["sglnCommercialPhone"];
            this.sisalCommercialName = _data["sisalCommercialName"];
            this.sisalCommercialMail = _data["sisalCommercialMail"];
            this.sisalCommercialPhone = _data["sisalCommercialPhone"];
            this.isMassAssignement = _data["isMassAssignement"];
            this.targetMunicipality = _data["targetMunicipality"];
        }
    }

    static fromJS(data: any): SalesRepresentativeDto {
        data = typeof data === 'object' ? data : {};
        let result = new SalesRepresentativeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sglnCommercialName"] = this.sglnCommercialName;
        data["sglnCommercialMail"] = this.sglnCommercialMail;
        data["sglnCommercialPhone"] = this.sglnCommercialPhone;
        data["sisalCommercialName"] = this.sisalCommercialName;
        data["sisalCommercialMail"] = this.sisalCommercialMail;
        data["sisalCommercialPhone"] = this.sisalCommercialPhone;
        data["isMassAssignement"] = this.isMassAssignement;
        data["targetMunicipality"] = this.targetMunicipality;
        return data; 
    }
}

export interface ISalesRepresentativeDto {
    sglnCommercialName?: string | undefined;
    sglnCommercialMail?: string | undefined;
    sglnCommercialPhone?: string | undefined;
    sisalCommercialName?: string | undefined;
    sisalCommercialMail?: string | undefined;
    sisalCommercialPhone?: string | undefined;
    isMassAssignement?: boolean;
    targetMunicipality?: string | undefined;
}

export class RoleDto implements IRoleDto {
    roleName?: string | undefined;
    id?: string | undefined;

    constructor(data?: IRoleDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.roleName = _data["roleName"];
            this.id = _data["id"];
        }
    }

    static fromJS(data: any): RoleDto {
        data = typeof data === 'object' ? data : {};
        let result = new RoleDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["roleName"] = this.roleName;
        data["id"] = this.id;
        return data; 
    }
}

export interface IRoleDto {
    roleName?: string | undefined;
    id?: string | undefined;
}

export class PagedResultOfApplicationDocument extends PagedResultBase implements IPagedResultOfApplicationDocument {
    results?: ApplicationDocument[] | undefined;

    constructor(data?: IPagedResultOfApplicationDocument) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(ApplicationDocument.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultOfApplicationDocument {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfApplicationDocument();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IPagedResultOfApplicationDocument extends IPagedResultBase {
    results?: ApplicationDocument[] | undefined;
}

export class ApplicationDocument extends AbstractDocument implements IApplicationDocument {
    title?: string | undefined;

    constructor(data?: IApplicationDocument) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.title = _data["title"];
        }
    }

    static fromJS(data: any): ApplicationDocument {
        data = typeof data === 'object' ? data : {};
        let result = new ApplicationDocument();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        super.toJSON(data);
        return data; 
    }
}

export interface IApplicationDocument extends IAbstractDocument {
    title?: string | undefined;
}

export class TrainingModuleDTO implements ITrainingModuleDTO {
    id?: string;
    title?: string | undefined;
    countTrainings?: number;
    created?: Date;

    constructor(data?: ITrainingModuleDTO) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.title = _data["title"];
            this.countTrainings = _data["countTrainings"];
            this.created = _data["created"] ? new Date(_data["created"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): TrainingModuleDTO {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingModuleDTO();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["title"] = this.title;
        data["countTrainings"] = this.countTrainings;
        data["created"] = this.created ? this.created.toISOString() : <any>undefined;
        return data; 
    }
}

export interface ITrainingModuleDTO {
    id?: string;
    title?: string | undefined;
    countTrainings?: number;
    created?: Date;
}

export class TrainingModule extends BaseEntityOfGuid implements ITrainingModule {
    title?: string | undefined;
    trainings?: Training[] | undefined;

    constructor(data?: ITrainingModule) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.title = _data["title"];
            if (Array.isArray(_data["trainings"])) {
                this.trainings = [] as any;
                for (let item of _data["trainings"])
                    this.trainings!.push(Training.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TrainingModule {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingModule();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        if (Array.isArray(this.trainings)) {
            data["trainings"] = [];
            for (let item of this.trainings)
                data["trainings"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface ITrainingModule extends IBaseEntityOfGuid {
    title?: string | undefined;
    trainings?: Training[] | undefined;
}

export class Training extends BaseEntityOfGuid implements ITraining {
    module?: TrainingModule | undefined;
    moduleId?: string | undefined;
    title?: string | undefined;
    description?: string | undefined;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    type?: TrainingType;
    courseURI?: string | undefined;
    questions?: TrainingQuestion[] | undefined;
    documents?: TrainingDocument[] | undefined;
    retailerTrainings?: RetailerTraining[] | undefined;
    isPublished?: boolean;

    constructor(data?: ITraining) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.module = _data["module"] ? TrainingModule.fromJS(_data["module"]) : <any>undefined;
            this.moduleId = _data["moduleId"];
            this.title = _data["title"];
            this.description = _data["description"];
            this.startDate = _data["startDate"] ? new Date(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? new Date(_data["endDate"].toString()) : <any>undefined;
            this.type = _data["type"];
            this.courseURI = _data["courseURI"];
            if (Array.isArray(_data["questions"])) {
                this.questions = [] as any;
                for (let item of _data["questions"])
                    this.questions!.push(TrainingQuestion.fromJS(item));
            }
            if (Array.isArray(_data["documents"])) {
                this.documents = [] as any;
                for (let item of _data["documents"])
                    this.documents!.push(TrainingDocument.fromJS(item));
            }
            if (Array.isArray(_data["retailerTrainings"])) {
                this.retailerTrainings = [] as any;
                for (let item of _data["retailerTrainings"])
                    this.retailerTrainings!.push(RetailerTraining.fromJS(item));
            }
            this.isPublished = _data["isPublished"];
        }
    }

    static fromJS(data: any): Training {
        data = typeof data === 'object' ? data : {};
        let result = new Training();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["module"] = this.module ? this.module.toJSON() : <any>undefined;
        data["moduleId"] = this.moduleId;
        data["title"] = this.title;
        data["description"] = this.description;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["type"] = this.type;
        data["courseURI"] = this.courseURI;
        if (Array.isArray(this.questions)) {
            data["questions"] = [];
            for (let item of this.questions)
                data["questions"].push(item.toJSON());
        }
        if (Array.isArray(this.documents)) {
            data["documents"] = [];
            for (let item of this.documents)
                data["documents"].push(item.toJSON());
        }
        if (Array.isArray(this.retailerTrainings)) {
            data["retailerTrainings"] = [];
            for (let item of this.retailerTrainings)
                data["retailerTrainings"].push(item.toJSON());
        }
        data["isPublished"] = this.isPublished;
        super.toJSON(data);
        return data; 
    }
}

export interface ITraining extends IBaseEntityOfGuid {
    module?: TrainingModule | undefined;
    moduleId?: string | undefined;
    title?: string | undefined;
    description?: string | undefined;
    startDate?: Date | undefined;
    endDate?: Date | undefined;
    type?: TrainingType;
    courseURI?: string | undefined;
    questions?: TrainingQuestion[] | undefined;
    documents?: TrainingDocument[] | undefined;
    retailerTrainings?: RetailerTraining[] | undefined;
    isPublished?: boolean;
}

export enum TrainingType {
    Interactive = "Interactive",
    Live = "Live",
    Video = "Video",
}

export class TrainingQuestion extends BaseEntityOfGuid implements ITrainingQuestion {
    label?: string | undefined;
    training?: Training | undefined;
    trainingId?: string;
    options?: TrainingQuestionOption[] | undefined;

    constructor(data?: ITrainingQuestion) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.label = _data["label"];
            this.training = _data["training"] ? Training.fromJS(_data["training"]) : <any>undefined;
            this.trainingId = _data["trainingId"];
            if (Array.isArray(_data["options"])) {
                this.options = [] as any;
                for (let item of _data["options"])
                    this.options!.push(TrainingQuestionOption.fromJS(item));
            }
        }
    }

    static fromJS(data: any): TrainingQuestion {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingQuestion();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["label"] = this.label;
        data["training"] = this.training ? this.training.toJSON() : <any>undefined;
        data["trainingId"] = this.trainingId;
        if (Array.isArray(this.options)) {
            data["options"] = [];
            for (let item of this.options)
                data["options"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface ITrainingQuestion extends IBaseEntityOfGuid {
    label?: string | undefined;
    training?: Training | undefined;
    trainingId?: string;
    options?: TrainingQuestionOption[] | undefined;
}

export class TrainingQuestionOption extends BaseEntityOfGuid implements ITrainingQuestionOption {
    label?: string | undefined;
    isCorrect?: boolean;
    trainingQuestionId?: string;
    trainingQuestion?: TrainingQuestion | undefined;

    constructor(data?: ITrainingQuestionOption) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.label = _data["label"];
            this.isCorrect = _data["isCorrect"];
            this.trainingQuestionId = _data["trainingQuestionId"];
            this.trainingQuestion = _data["trainingQuestion"] ? TrainingQuestion.fromJS(_data["trainingQuestion"]) : <any>undefined;
        }
    }

    static fromJS(data: any): TrainingQuestionOption {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingQuestionOption();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["label"] = this.label;
        data["isCorrect"] = this.isCorrect;
        data["trainingQuestionId"] = this.trainingQuestionId;
        data["trainingQuestion"] = this.trainingQuestion ? this.trainingQuestion.toJSON() : <any>undefined;
        super.toJSON(data);
        return data; 
    }
}

export interface ITrainingQuestionOption extends IBaseEntityOfGuid {
    label?: string | undefined;
    isCorrect?: boolean;
    trainingQuestionId?: string;
    trainingQuestion?: TrainingQuestion | undefined;
}

export class TrainingDocument extends AbstractDocument implements ITrainingDocument {
    training?: Training | undefined;
    trainingId?: string;
    title?: string | undefined;
    body?: string | undefined;

    constructor(data?: ITrainingDocument) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.training = _data["training"] ? Training.fromJS(_data["training"]) : <any>undefined;
            this.trainingId = _data["trainingId"];
            this.title = _data["title"];
            this.body = _data["body"];
        }
    }

    static fromJS(data: any): TrainingDocument {
        data = typeof data === 'object' ? data : {};
        let result = new TrainingDocument();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["training"] = this.training ? this.training.toJSON() : <any>undefined;
        data["trainingId"] = this.trainingId;
        data["title"] = this.title;
        data["body"] = this.body;
        super.toJSON(data);
        return data; 
    }
}

export interface ITrainingDocument extends IAbstractDocument {
    training?: Training | undefined;
    trainingId?: string;
    title?: string | undefined;
    body?: string | undefined;
}

export class RetailerTraining extends BaseEntityOfGuid implements IRetailerTraining {
    retailer?: Retailer | undefined;
    retailerId?: string;
    training?: Training | undefined;
    trainingId?: string;
    lastStatus?: TrainingStatusType;
    score?: number | undefined;
    scoreRate?: number | undefined;
    statuses?: RetailerTrainingStatus[] | undefined;

    constructor(data?: IRetailerTraining) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.retailer = _data["retailer"] ? Retailer.fromJS(_data["retailer"]) : <any>undefined;
            this.retailerId = _data["retailerId"];
            this.training = _data["training"] ? Training.fromJS(_data["training"]) : <any>undefined;
            this.trainingId = _data["trainingId"];
            this.lastStatus = _data["lastStatus"];
            this.score = _data["score"];
            this.scoreRate = _data["scoreRate"];
            if (Array.isArray(_data["statuses"])) {
                this.statuses = [] as any;
                for (let item of _data["statuses"])
                    this.statuses!.push(RetailerTrainingStatus.fromJS(item));
            }
        }
    }

    static fromJS(data: any): RetailerTraining {
        data = typeof data === 'object' ? data : {};
        let result = new RetailerTraining();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["retailer"] = this.retailer ? this.retailer.toJSON() : <any>undefined;
        data["retailerId"] = this.retailerId;
        data["training"] = this.training ? this.training.toJSON() : <any>undefined;
        data["trainingId"] = this.trainingId;
        data["lastStatus"] = this.lastStatus;
        data["score"] = this.score;
        data["scoreRate"] = this.scoreRate;
        if (Array.isArray(this.statuses)) {
            data["statuses"] = [];
            for (let item of this.statuses)
                data["statuses"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IRetailerTraining extends IBaseEntityOfGuid {
    retailer?: Retailer | undefined;
    retailerId?: string;
    training?: Training | undefined;
    trainingId?: string;
    lastStatus?: TrainingStatusType;
    score?: number | undefined;
    scoreRate?: number | undefined;
    statuses?: RetailerTrainingStatus[] | undefined;
}

export enum TrainingStatusType {
    InProgress = "InProgress",
    CourseFinished = "CourseFinished",
    TestCompleted = "TestCompleted",
}

export class RetailerTrainingStatus extends BaseEntityOfGuid implements IRetailerTrainingStatus {
    retailerTraining?: RetailerTraining | undefined;
    retailerTrainingId?: string;
    statusType?: TrainingStatusType;

    constructor(data?: IRetailerTrainingStatus) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.retailerTraining = _data["retailerTraining"] ? RetailerTraining.fromJS(_data["retailerTraining"]) : <any>undefined;
            this.retailerTrainingId = _data["retailerTrainingId"];
            this.statusType = _data["statusType"];
        }
    }

    static fromJS(data: any): RetailerTrainingStatus {
        data = typeof data === 'object' ? data : {};
        let result = new RetailerTrainingStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["retailerTraining"] = this.retailerTraining ? this.retailerTraining.toJSON() : <any>undefined;
        data["retailerTrainingId"] = this.retailerTrainingId;
        data["statusType"] = this.statusType;
        super.toJSON(data);
        return data; 
    }
}

export interface IRetailerTrainingStatus extends IBaseEntityOfGuid {
    retailerTraining?: RetailerTraining | undefined;
    retailerTrainingId?: string;
    statusType?: TrainingStatusType;
}

export class PagedResultOfTraining extends PagedResultBase implements IPagedResultOfTraining {
    results?: Training[] | undefined;

    constructor(data?: IPagedResultOfTraining) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(Training.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultOfTraining {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfTraining();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IPagedResultOfTraining extends IPagedResultBase {
    results?: Training[] | undefined;
}

export class InteractiveTrainingDocumentVm implements IInteractiveTrainingDocumentVm {
    trainingTitle?: string | undefined;
    moduleName?: string | undefined;
    listTrainingCourseSlide?: InteractiveTrainingCourseSlideVm[] | undefined;

    constructor(data?: IInteractiveTrainingDocumentVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.trainingTitle = _data["trainingTitle"];
            this.moduleName = _data["moduleName"];
            if (Array.isArray(_data["listTrainingCourseSlide"])) {
                this.listTrainingCourseSlide = [] as any;
                for (let item of _data["listTrainingCourseSlide"])
                    this.listTrainingCourseSlide!.push(InteractiveTrainingCourseSlideVm.fromJS(item));
            }
        }
    }

    static fromJS(data: any): InteractiveTrainingDocumentVm {
        data = typeof data === 'object' ? data : {};
        let result = new InteractiveTrainingDocumentVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["trainingTitle"] = this.trainingTitle;
        data["moduleName"] = this.moduleName;
        if (Array.isArray(this.listTrainingCourseSlide)) {
            data["listTrainingCourseSlide"] = [];
            for (let item of this.listTrainingCourseSlide)
                data["listTrainingCourseSlide"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IInteractiveTrainingDocumentVm {
    trainingTitle?: string | undefined;
    moduleName?: string | undefined;
    listTrainingCourseSlide?: InteractiveTrainingCourseSlideVm[] | undefined;
}

export class InteractiveTrainingCourseSlideVm implements IInteractiveTrainingCourseSlideVm {
    title?: string | undefined;
    body?: string | undefined;
    id?: string;
    type?: DocumentType;

    constructor(data?: IInteractiveTrainingCourseSlideVm) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.body = _data["body"];
            this.id = _data["id"];
            this.type = _data["type"];
        }
    }

    static fromJS(data: any): InteractiveTrainingCourseSlideVm {
        data = typeof data === 'object' ? data : {};
        let result = new InteractiveTrainingCourseSlideVm();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["body"] = this.body;
        data["id"] = this.id;
        data["type"] = this.type;
        return data; 
    }
}

export interface IInteractiveTrainingCourseSlideVm {
    title?: string | undefined;
    body?: string | undefined;
    id?: string;
    type?: DocumentType;
}

export class InteractiveTrainingDto implements IInteractiveTrainingDto {
    title?: string | undefined;
    description?: string | undefined;
    moduleId?: string;
    courseSlides?: CourseSlideContentDto[] | undefined;
    courseQuestions?: CourseQuestionsDto[] | undefined;

    constructor(data?: IInteractiveTrainingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.description = _data["description"];
            this.moduleId = _data["moduleId"];
            if (Array.isArray(_data["courseSlides"])) {
                this.courseSlides = [] as any;
                for (let item of _data["courseSlides"])
                    this.courseSlides!.push(CourseSlideContentDto.fromJS(item));
            }
            if (Array.isArray(_data["courseQuestions"])) {
                this.courseQuestions = [] as any;
                for (let item of _data["courseQuestions"])
                    this.courseQuestions!.push(CourseQuestionsDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): InteractiveTrainingDto {
        data = typeof data === 'object' ? data : {};
        let result = new InteractiveTrainingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["description"] = this.description;
        data["moduleId"] = this.moduleId;
        if (Array.isArray(this.courseSlides)) {
            data["courseSlides"] = [];
            for (let item of this.courseSlides)
                data["courseSlides"].push(item.toJSON());
        }
        if (Array.isArray(this.courseQuestions)) {
            data["courseQuestions"] = [];
            for (let item of this.courseQuestions)
                data["courseQuestions"].push(item.toJSON());
        }
        return data; 
    }
}

export interface IInteractiveTrainingDto {
    title?: string | undefined;
    description?: string | undefined;
    moduleId?: string;
    courseSlides?: CourseSlideContentDto[] | undefined;
    courseQuestions?: CourseQuestionsDto[] | undefined;
}

export class CourseSlideContentDto implements ICourseSlideContentDto {
    image?: string | undefined;
    body?: string | undefined;
    order?: number;

    constructor(data?: ICourseSlideContentDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.image = _data["image"];
            this.body = _data["body"];
            this.order = _data["order"];
        }
    }

    static fromJS(data: any): CourseSlideContentDto {
        data = typeof data === 'object' ? data : {};
        let result = new CourseSlideContentDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["image"] = this.image;
        data["body"] = this.body;
        data["order"] = this.order;
        return data; 
    }
}

export interface ICourseSlideContentDto {
    image?: string | undefined;
    body?: string | undefined;
    order?: number;
}

export class CourseQuestionsDto implements ICourseQuestionsDto {
    options?: string[] | undefined;
    correctOptionIndex?: number;
    label?: string | undefined;

    constructor(data?: ICourseQuestionsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["options"])) {
                this.options = [] as any;
                for (let item of _data["options"])
                    this.options!.push(item);
            }
            this.correctOptionIndex = _data["correctOptionIndex"];
            this.label = _data["label"];
        }
    }

    static fromJS(data: any): CourseQuestionsDto {
        data = typeof data === 'object' ? data : {};
        let result = new CourseQuestionsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.options)) {
            data["options"] = [];
            for (let item of this.options)
                data["options"].push(item);
        }
        data["correctOptionIndex"] = this.correctOptionIndex;
        data["label"] = this.label;
        return data; 
    }
}

export interface ICourseQuestionsDto {
    options?: string[] | undefined;
    correctOptionIndex?: number;
    label?: string | undefined;
}

export class VideoTrainingDto implements IVideoTrainingDto {
    title?: string | undefined;
    courseURI?: string | undefined;

    constructor(data?: IVideoTrainingDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.title = _data["title"];
            this.courseURI = _data["courseURI"];
        }
    }

    static fromJS(data: any): VideoTrainingDto {
        data = typeof data === 'object' ? data : {};
        let result = new VideoTrainingDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["title"] = this.title;
        data["courseURI"] = this.courseURI;
        return data; 
    }
}

export interface IVideoTrainingDto {
    title?: string | undefined;
    courseURI?: string | undefined;
}

export class PagedResultOfUser extends PagedResultBase implements IPagedResultOfUser {
    results?: User[] | undefined;

    constructor(data?: IPagedResultOfUser) {
        super(data);
    }

    init(_data?: any) {
        super.init(_data);
        if (_data) {
            if (Array.isArray(_data["results"])) {
                this.results = [] as any;
                for (let item of _data["results"])
                    this.results!.push(User.fromJS(item));
            }
        }
    }

    static fromJS(data: any): PagedResultOfUser {
        data = typeof data === 'object' ? data : {};
        let result = new PagedResultOfUser();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.results)) {
            data["results"] = [];
            for (let item of this.results)
                data["results"].push(item.toJSON());
        }
        super.toJSON(data);
        return data; 
    }
}

export interface IPagedResultOfUser extends IPagedResultBase {
    results?: User[] | undefined;
}

export class ChangePasswordData implements IChangePasswordData {
    currentPassword!: string;
    newPassword!: string;

    constructor(data?: IChangePasswordData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currentPassword = _data["currentPassword"];
            this.newPassword = _data["newPassword"];
        }
    }

    static fromJS(data: any): ChangePasswordData {
        data = typeof data === 'object' ? data : {};
        let result = new ChangePasswordData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentPassword"] = this.currentPassword;
        data["newPassword"] = this.newPassword;
        return data; 
    }
}

export interface IChangePasswordData {
    currentPassword: string;
    newPassword: string;
}

export class Result implements IResult {
    succeeded?: boolean;
    errors?: string[] | undefined;

    constructor(data?: IResult) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.succeeded = _data["succeeded"];
            if (Array.isArray(_data["errors"])) {
                this.errors = [] as any;
                for (let item of _data["errors"])
                    this.errors!.push(item);
            }
        }
    }

    static fromJS(data: any): Result {
        data = typeof data === 'object' ? data : {};
        let result = new Result();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["succeeded"] = this.succeeded;
        if (Array.isArray(this.errors)) {
            data["errors"] = [];
            for (let item of this.errors)
                data["errors"].push(item);
        }
        return data; 
    }
}

export interface IResult {
    succeeded?: boolean;
    errors?: string[] | undefined;
}

export class UserDto implements IUserDto {
    email?: string | undefined;
    firstName?: string | undefined;
    userName?: string | undefined;
    lastName?: string | undefined;
    phoneNumber?: string | undefined;
    roleName?: string | undefined;
    administration?: ProcessingDirectionType | undefined;

    constructor(data?: IUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.firstName = _data["firstName"];
            this.userName = _data["userName"];
            this.lastName = _data["lastName"];
            this.phoneNumber = _data["phoneNumber"];
            this.roleName = _data["roleName"];
            this.administration = _data["administration"];
        }
    }

    static fromJS(data: any): UserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["firstName"] = this.firstName;
        data["userName"] = this.userName;
        data["lastName"] = this.lastName;
        data["phoneNumber"] = this.phoneNumber;
        data["roleName"] = this.roleName;
        data["administration"] = this.administration;
        return data; 
    }
}

export interface IUserDto {
    email?: string | undefined;
    firstName?: string | undefined;
    userName?: string | undefined;
    lastName?: string | undefined;
    phoneNumber?: string | undefined;
    roleName?: string | undefined;
    administration?: ProcessingDirectionType | undefined;
}

export class UserUpdateDto implements IUserUpdateDto {
    id?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    phoneNumber?: string | undefined;
    userName?: string | undefined;
    roleName?: string | undefined;
    administration?: ProcessingDirectionType | undefined;

    constructor(data?: IUserUpdateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.phoneNumber = _data["phoneNumber"];
            this.userName = _data["userName"];
            this.roleName = _data["roleName"];
            this.administration = _data["administration"];
        }
    }

    static fromJS(data: any): UserUpdateDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserUpdateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["phoneNumber"] = this.phoneNumber;
        data["userName"] = this.userName;
        data["roleName"] = this.roleName;
        data["administration"] = this.administration;
        return data; 
    }
}

export interface IUserUpdateDto {
    id?: string | undefined;
    firstName?: string | undefined;
    lastName?: string | undefined;
    phoneNumber?: string | undefined;
    userName?: string | undefined;
    roleName?: string | undefined;
    administration?: ProcessingDirectionType | undefined;
}

export class UserResetDto implements IUserResetDto {
    email?: string | undefined;
    newPassword?: string | undefined;
    code?: string | undefined;

    constructor(data?: IUserResetDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.newPassword = _data["newPassword"];
            this.code = _data["code"];
        }
    }

    static fromJS(data: any): UserResetDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserResetDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["newPassword"] = this.newPassword;
        data["code"] = this.code;
        return data; 
    }
}

export interface IUserResetDto {
    email?: string | undefined;
    newPassword?: string | undefined;
    code?: string | undefined;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class SwaggerException extends Error {
    message: string;
    status: number; 
    response: string; 
    headers: { [key: string]: any; };
    result: any; 

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): any {
    if (result !== null && result !== undefined)
        throw result;
    else
        throw new SwaggerException(message, status, response, headers, null);
}